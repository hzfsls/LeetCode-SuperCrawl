## [287.寻找重复数 中文热门题解1](https://leetcode.cn/problems/find-the-duplicate-number/solutions/100000/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419)

作者：[liweiwei1419](https://leetcode.cn/u/liweiwei1419)

## 🖥 视频讲解

[8-9 「力扣」第 287 题：寻找重复数](https://www.bilibili.com/video/BV1eT411u7oD?spm_id_from=333.999.0.0&vd_source=8d4c0bb6f04271cbe95d70f568c88555)。

## 解题思路

+ 题目要求查找重复的整数，很容易想到使用「哈希表」，但是题目中要求「只用常量级 $O(1)$ 的额外空间」，该方法不符合题意；
+ 还可以考虑使用「力扣」第 41 题：[缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive) 的技巧，使用「原地哈希」，但是题目要求「你设计的解决方案必须不修改数组 `nums`」，该方法不符合题意；
+ 但是题目中还说：**「数字都在 $1$ 到 $n$ 之间（包括 $1$ 和 $n$）」，查找一个有范围的整数，可以使用「二分查找」（这一点很重要，很多「二分查找」的问题就是要我们找一个整数）**；
+ 「快慢指针」的做法很有技巧，具体做法请见其它题解。

## 可以使用「二分查找」的原因

因为题目要找的是一个 **整数**，并且这个整数有明确的范围，所以可以使用「二分查找」。

**重点理解**：

> 这个问题使用「二分查找」是在数组 `[1, 2,.., n]` 中查找一个整数，而 **并非在输入数组数组中查找一个整数**。

使用「二分查找」查找一个整数，这是「二分查找」的典型应用，经常被称为「二分答案」。在 [题解](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/) 中，「题型二」与「题型三」都是这样的问题。

央视《幸运 52》节目的「猜价格游戏」，就是「二分答案」。玩家猜一个数字，如果猜中，游戏结束，如果主持人说「猜高了」，应该猜一个更低的价格，如果主持人说「猜低了」，应该猜一个更高的价格。

---

继续 **解题思路**：每一次猜一个数，然后 **遍历整个输入数组**，进而缩小搜索区间，最后确定重复的是哪个数。

**理解题意**：

+ `n + 1` 个整数，放在长度为 `n` 的数组里，根据「抽屉原理」，至少会有 `1` 个整数是重复的；

> [抽屉原理](https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%8E%9F%E7%90%86/233776)：把 `10` 个苹果放进 `9` 个抽屉，至少有一个抽屉里至少放 `2` 个苹果。


---

### 方法：二分查找

「二分查找」的思路是先猜一个数（搜索范围 `[left..right]` 里位于中间的数 `mid`），然后统计原始数组中 **小于等于** `mid` 的元素的个数 `count`：

1. 如果 `count` **严格大于** `mid`。根据 **抽屉原理**，重复元素就在区间 `[left..mid]` 里；
2. 否则，重复元素可以在区间 `[mid + 1..right]` 里找到，其实只要第 1 点是对的，这里肯定是对的，但要说明这一点，需要一些推导，我们放在最后说。


**参考代码**：

```Java []
class Solution {

    public int findDuplicate(int[] nums) {
        int len = nums.length; // n + 1 = len, n = len - 1

        // 在 [1..n] 查找 nums 中重复的元素
        int left = 1;
        int right = len - 1;
        while (left < right) {
            int mid = (left + right) / 2;

            // nums 中小于等于 mid 的元素的个数
            int count = 0;
            for (int num : nums) {
                if (num <= mid) {
                    count++;
                }
            }

            if (count > mid) {
                // 下一轮搜索的区间 [left..mid]
                right = mid;
            } else {
                // 下一轮搜索的区间 [mid + 1..right]
                left = mid + 1;
            }
        }
        return left;
    }
}
```

**解释**：

+ 题目中说：长度为 `n + 1` 的数组，数值在 `1` 到 `n` 之间。因此长度为 `len = n + 1`，`n = len - 1`，搜索范围在 `1` 到 `len - 1` 之间；
+ 使用 `while (left < right)` 与 `right = mid;` 和 `left = mid + 1;` 配对的写法是为了保证：退出循环以后 `left` 与 `right` 重合，`left` （或者 `right`）就是我们要找的重复的整数；
+ 在 **循环体内**，先猜一个数 `mid`，然后遍历「输入数组」，统计小于等于 `mid` 的元素个数 `count`，如果 `count > mid` 说明重复元素一定出现在 `[left..mid]` 因此设置 `right = mid`；

> 如果觉得上面这句话比较绕的话，可以用一个具体的例子来理解：如果遍历一遍输入数组，统计小于 **等于** `4` 的元素的个数，如果小于等于 `4` 的元素的个数 **严格** 大于 `4` ，说明重复的元素一定出现在整数区间 `[1..4]`，依然是利用了「抽屉原理」，注意这里加着重号的地方。


**复杂度分析**：

+ 时间复杂度：$O(N \log N)$，二分法的时间复杂度为 $O(\log N)$，在二分法的内部，执行了一次 `for` 循环，时间复杂度为 $O(N)$，故时间复杂度为 $O(N \log N)$。
+ 空间复杂度：$O(1)$，使用了一个 `cnt` 变量，因此空间复杂度为 $O(1)$。


**补充 1**：


+ 但本题的场景和限制是极其特殊的，实际工作中和绝大多数算法问题都不会用「时间换空间」；
+ 关于如何使用「二分查找」做对「力扣」上所有的问题，可以看第 35 题的 [题解](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/)；
+ 这题二分查找和快慢指针都不是常规思路，面试的时候最好提一下：因为有各种限制，才用二分这种耗时的做法，用快慢指针是因为做过类似的问题。

**补充 2**：



`else` 里面当 `count <= mid` 的时候，为什么可以说明 `[mid + 1..right]` 里出现了重复数。

当 `count <= mid`，重复的元素当然有可能出现在 `[left..mid]` 但是，在 `[mid + 1..right]` 里一定会出现重复元素。这是因为：

+ 整数区间 `[mid + 1..right]` 里的元素的个数为 `len - count`；
+ 因为 `right = len - 1`，所以 `len - count = right + 1 - count`；
+ 又因为 `count <= mid`，`len - count >= right + 1 - mid`；
+ 而区间 `[mid + 1..right]` 里一共有 `right - mid` 个整数。所以 `right - mid` 个整数，至少出现了 `right + 1 - mid` 次，根据 **抽屉原理**，在 `[mid + 1..right]` 里一定会出现重复元素。

其实是重复论证了 `if` 语句。


