## [35.搜索插入位置 中文热门题解1](https://leetcode.cn/problems/search-insert-position/solutions/100000/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-)

作者：[liweiwei1419](https://leetcode.cn/u/liweiwei1419)
**说明**：

- 本题解原来有「二分查找」总结的，现在总结到网站「算法吧」里了，地址在 [这里](https://suanfa8.com/binary-search) ，以前看到过想复习的朋友，可以看看这里。如果你觉得二分查找很难掌握，总是写不对，可以好好看看，有视频，也有文字讲解；
- 本次更新根据一些朋友在「力扣」、B 站和其它平台的反馈，我把这道题再讲得细一点，尽可能把所有的情况都讲到；
- 还有朋友让我解释一下其它版本的代码，我放在了「五、其它代码讲解」。


---

## 一、题意分析

这道题让我们找「目标值」在「有序数组中」会被「按照顺序插入的位置」。具体什么是「按照顺序插入的位置」，需要看 3 个「示例」：

- 根据「示例 1」和「示例 2」，可知：题目要我们找出第 1 个 **大于等于** 目标元素的下标。**这一点是解对这个问题的前提，如果题意分析错误，代码肯定写不对**；
- 根据「示例 3」，可知：如果目标元素 **严格大于** 输入数组的最后一个元素，题目要我们返回数组的最后一个元素的下标 `+1`（也就是数组的长度），因为有可能输入数组中所有的元素都 **严格** 小于「目标值」；
- **注意**：题目最后的「提示」中说，`nums` 不为空，`nums` 没有重复元素。

## 二、思路分析

在 **有序数组** 中查找符合条件的某个数（或者它的下标），可以使用二分查找。

我们根据搜索区间 `[left..right]` 中间位置 `mid` 的值，判断下一轮搜索区间在哪里。根据「一、题意分析」中对示例的描述：

（这里多说一句：下面的「情况 1」和「情况 2」的分析完全是分析本题题意得到的，如果有不太清楚的地方，把题目中的 3 个「示例」多看几遍。）


- **情况 1**：如果当前 `mid` 看到的数值严格小于 `target`，那么 `mid` 以及 `mid` 左边的所有元素就一定不是「插入元素的位置」，因此下一轮搜索区间是 `[mid + 1..right]`，下一轮把 `left` 移动到 `mid + 1` 位置，因此设置 `left = mid + 1`；


- **情况 2**：否则。如果 `mid` 看到的数值大于等于 `target`，那么 `mid` **可能是「插入元素的位置」**，`mid` 的右边一定不是「插入元素的位置」。如果 `mid` 的左边不存在「插入元素的位置」，我们才可以说 `mid` 是「插入元素的位置」。因此下一轮搜索区间是 `[left..mid]`，下一轮把 `right` 移动到 `mid` 位置，因此设置 `right = mid`。

**说明**：上面的两点中，「情况 2」其实不用分析得那么细致， 因为只要「情况 1」的区间分析是正确的，「情况 2」一定是「情况 1」得到的区间的反面区间。

## 三、本题的特点（我把上面的「情况 2」又说了一遍）

看到一个数大于等于目标元素，此时不能说它一定是第一个大于等于目标元素的元素。

- 如果它的左边没有大于等于目标元素的元素，它才是第一个大于等于目标元素的元素；
- 如果它的左边有大于等于目标元素的元素，它不是第一个大于等于目标元素的元素。

就是这样的特点决定了：**这个问题的答案有些时候需要再退出循环以后才能得到**。


## 四、参考代码

如果你非常清楚「二分查找」，或者看过我讲的「二分查找」的视频或者题解，下面的代码应该不难理解。我在「五、其它代码讲解」会说明：**本题解里所有的代码其实是一样的，就只有一种解法，特殊情况和边界的分析也完全一样**。

**参考代码 1**：

```java
public class Solution {

    public int searchInsert(int[] nums, int target) {
        // 不用判断数组为空，因为题目最后给出的数据范围说数组不为空
        int len = nums.length;
        // 特殊判断
        if (nums[len - 1] < target) {
            return len;
        }

        // 程序走到这里一定有 nums[len - 1] >= target，插入位置在区间 [0..len - 1]
        int left = 0;
        int right = len - 1;
        // 在区间 nums[left..right] 里查找第 1 个大于等于 target 的元素的下标
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] < target){
                // 下一轮搜索的区间是 [mid + 1..right]
                left = mid + 1;
            } else {
                // 下一轮搜索的区间是 [left..mid]
                right = mid;
            }
        }
        return left;
    }
}
```

**说明**：

- `while (left < right)` 表示当 `left` 与 `right` 重合的时候，我们找到了「目标值」的下标；
- **根据题意和示例**，当代码中的「特殊判断」不成立时，区间里一定存在大于等于「目标值」的元素；
- `while` 循环里只把区间分成两个部分，退出循环的时候一定有 `left == right` 成立，所以 `left` 与 `right` 重合的这个位置就是问题的答案，因此返回 `left` 或者 `right` 都可以。

因为题目的最后说：`nums` 中没有重复元素，所以可以在循环体里面加一个判断：

```java
if (nums[mid] == target) {
    return mid;
}
```



**复杂度分析**：

- 时间复杂度：$O(\log N)$，这里 $N$ 是输入数组的长度；
- 空间复杂度：$O(1)$。

既然 `len` 也有可能是答案，可以在初始化的时候，把 `right` 设置成 `len`，在一开始的时候就不需要特殊判断了。

**参考代码 2**：

```java
public class Solution {

    public int searchInsert(int[] nums, int target) {
        int len = nums.length;
        int left = 0;
        int right = len;
        // 在区间 nums[left..right] 里查找第 1 个大于等于 target 的元素的下标
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target){
                // 下一轮搜索的区间是 [mid + 1..right]
                left = mid + 1;
            } else {
                // 下一轮搜索的区间是 [left..mid]
                right = mid;
            }
        }
        return left;
    }
}
```

**复杂度分析**：（同参考代码 1）。

**说明**：

- 「参考代码 1」和「参考代码 2」其实是一版代码。「参考代码 1」其实就是做了先特殊的判断，特殊的判断不满足的时候，在一个更小的区间里做「二分查找」。

- 有的朋友把「参考代码 2」解释成：`while (left < right)` 表示搜索区间是 `[left..right)` ，所以初始化的时候 `right = len`，这样的解释是大错特错的。错误的地方在于：`while (left < right)` 表示搜索区间是 `[left..right)`，这句就不成立。`while (left < right)` 只表示它本来的意思：循环可以继续的条件是 `left < right`。

初始化的时候设置 `right = len` ，是因为这道题搜索的右边界本来就是 `[0..len]`。

（如果你看到这里有点晕，直接跳到最后，我有解释。）

## 五、其它代码讲解

**代码 1**：

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int n = nums.length;
        int left = 0, right = n - 1, ans = n;
        while (left <= right) {
            int mid = ((right - left) >> 1) + left;
            if (target <= nums[mid]) {
                ans = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }
}
```


作者：LeetCode-Solution
链接：https://leetcode.cn/problems/search-insert-position/solution/sou-suo-cha-ru-wei-zhi-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


**解释**：

- 这里的 `ans` 的含义是，把有可能是题目答案的结果用 `ans` 保存起来，所以 `ans` 初始化的时候应该设置为 `n`（根据 「示例」3）；
- 在 `if` 语句里 `nums[mid] >= target` 的时候，`mid` 位置有可能是问题的答案，所以需要用 `ans` 把 `mid` 保存起来（根据「二、思路分析」「情况 2」）；
- 最后要返回 `ans`。

由于有了 `ans` 变量，并且在 `if` 和 `else` 语句中 `left` 一定是 `mid + 1`，`right` 一定是 `mid - 1`，这种情况不会出现死循环，所以 `while` 里面可以写 `left <= right`。

其实这里的「代码 1」和上面给出的「参考代码 1」「参考代码 2」是一样的。其中：

- `ans` 的含义是：搜索区间的右边界；
- `right` 的含义是： 搜索区间的右边界 `-1`。


**代码 2**：

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while(left <= right) {
            int mid = (left + right) / 2;
            if(nums[mid] == target) {
                return mid;
            } else if(nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
}

```

作者：guanpengchn
链接：https://leetcode.cn/problems/search-insert-position/solution/hua-jie-suan-fa-35-sou-suo-cha-ru-wei-zhi-by-guanp/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


**解释**：

- 这一版代码里，所有关于右边界的设置，都要比真正的右边界少 $1$。也就是说，如果作者分析出搜索区间是 `[10, 20]`，他在代码里设置 `left = 10`, `right = 19`。除此之外，和「四、参考代码」里的「参考代码 2」是一样的；
- 因为数组的长度有可能是问题的答案，作者固定死了设置右边界的时候 `-1`，所以初始化的时候 `right = nums.length - 1;`；
- 循环体里面 `if (nums[mid] == target)` 我前面分析过，直接返回 `mid` 就好了，这里没有设置右边界；
- `else if (nums[mid] < target)` 我前面也分析过，此时设置左边界；
- `else` 是 `nums[mid] > target` 的时候，此时本该设置 `right = mid`，但是作者固定死了设置右边界的时候 `-1`，所以这里写 `right = mid - 1;`
- 因为固定死了设置右边界的时候 `-1`，所以退出循环的时候，`left` 和 `right` 不重合，`right` 比 `left` 少 `1`，所以返回 `left` 正确，返回 `right` 不正确，应该返回 `right + 1`，大家可以自己验证。

为什么 `while (left <= right)` 正确，还是因为固定死了设置右边界的时候 `-1`。当 `left` 与 `right` 重合的时候，虽然区间 `[left..right]` 里只有一个数，但是真正的右边界是 `right + 1`，所以此时还应该继续搜索下去。


## 六、总结

「二分查找」的写法很多、细节也很多。希望大家一定要有耐心，遇到问题的时候自己调试，把变量的值打印出来看一眼。

我相信，真正掌握「二分查找」的朋友，不是因为他（她）背下了「二分查找」的模板，而是他（她）对题目的意思有准确的理解。

就本题而言，一定要分析出：

- 数组的长度有可能是问题的答案，也就是 `nums.length` 有可能是问题的答案，如果不讨论，答案肯定错；
- 当 `nums[mid] >= target` 的时候，`mid` 有可能是问题的答案，如果直接去掉，也肯定错，这一点在「三、本题的特点 」里专门强调过。

任何模板都不会覆盖上面的信息，上面也和大家解释了其它版本的代码正确也离不开对上面两点的分析，本质上本题解里出现的代码都是一样的，所以审题很重要。



## 七、对「左闭右开」的解释（这里有一些吐槽，请见谅）

从开始在「力扣」写题解（2019 年 6 月）到现在已经有 4 年了，看到非常多的朋友说到「二分查找」的时候，总会说「二分细节爆炸」「天杀的二分」「二分很难写对」「左闭右开」这样的话，我整理了一下，原因如下：

- **讲的人不懂**：有这样想法的人可能看到过一些不负责任的算法自媒体，他们（不止一个）自己本来就没搞懂「二分查找」，还要制造焦虑，然后开始贩卖他们的知识。我们有的读者恰好很相信他们这一套；
- **听的人不质疑、不求证**：我们有的读者还真的是缺少思考和质疑、求证的精神，这些自媒体乱讲，他们也跟着相信，人云亦云。
 
我看到非常多的朋友说 `while (left < right)` 这种写法叫「左闭右开」，我在这里要很严肃地说一句：**这完全没有根据**。**很多朋友不加思考地接受了这样的结论，所以导致它们在理解一些「二分查找」代码的时候逻辑上的混乱和矛盾**。

即：「`while (left < right)`」 与「搜索区间为左闭右开」没有因果关系。

- `while (left < right)` 只表示它本来的意思，即：在 `left < right` 的时候循环可以继续，不能因为少了「等于」号，就说搜索区间为左闭右开 `[left..right)`。

- 什么叫区间左闭右开 `[left..right)`？左闭右开 `[left..right)` 等于左闭右闭区间 `[left..right - 1]`。

一个具体的问题，在条件确定的情况下，搜索的范围（区间）也是确定的。这个区间，你可以表示成「左闭右闭」区间（我的所有「二分查找」的题解里的所有代码）。也可以表示成「左闭右开」区间，比如本题解「五、其它代码讲解」的「代码 2」，把 `right` 设置成为真正的目标值存在区间的右边界 $-1$。


「二分查找」不会因为因为我们把区间表示成「左闭右闭」或者「左闭右开」而变得简单。大家会看到，表示成「左闭右开」反而更别扭。

很多朋友不假思索地在算法学习中应用别人写好的「代码模板」，如果只是为了把题目做对，有些时候是可以侥幸通过的。

在这个网站上，有很多种办法能让自己的代码通过测评，比起做对这些问题，我认为更重要的是解决问题的思想。希望大家在做题的时候，能够真的清楚每一行代码的意思。

讲解「二分查找」的人误导了很多人，希望大家能够仔细辨别。

如果你认为我在误导别人，首先恭喜你，质疑我本来就是你的权利和应该有的态度，我讲错的地方很多，被人纠正过很多次。其次，你可以有理有据说出我讲错的地方。我看到了，都会承认的。如果是恶意留言，我一条都不会回复。


希望我的讲解对大家有帮助！