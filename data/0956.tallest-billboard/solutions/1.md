## [956.最高的广告牌 中文热门题解1](https://leetcode.cn/problems/tallest-billboard/solutions/100000/yi-quan-ji-ben-mei-shuo-ming-bai-de-zhe-pian-kan-l)

作者：[liuchang](https://leetcode.cn/u/liuchang)
#### 思路：
**将问题转化为求数组和为0时的组合**
&nbsp;
对任何一个数，可以用三种方式对待它，乘以1，-1或0，目标是求和为0时的最大正数和
&nbsp;
例如，[1，2，3], 可以对1，2乘以1，3乘以-1，此时和为0， 最大正数和为1+2=3
**用字典来存储每一步的结果，键和值分别是(k:v) 总和以及正数和，**
初始化时dp={0:0},表示和为0时的最大长度为0
那么最后只需要求dp[0]的最大值就ok辣
&nbsp;
遍历所有钢筋：
对每根钢筋都有三种处理方式：加，减，丢 （对应乘以1，-1或0）
&nbsp;
如：[1,2,3]
**第一步**: 用钢筋1，对初始的0，操作
如果加，那么总和是1，正数是1；如果减，总和是-1，正数0；如果丢，维持不变；更新dp={0:0, 1:1, -1:0}
**第二步**: 用钢筋2，对第一步中dp的键0，1，-1的基础上分别进行“加，减，丢 ”的操作
在0:0基础上，如果加，也就是变为**2：2**；如果减，变为 **-2：0**； 如果丢，变成**0：0**
类似的，在1：1基础上，加减丢变为**3：3**，**-1：1**，1：1
类似的，在-1：0基础上，加减丢变为**1：2**，**-3：0**，-1：0
**每个键取较大值，用粗体标识了**，然后更新dp={0:0, 1:2, 2:2, -1:1, 3:3, -2:0, -3:0} 
总和为1时，相比第一步时的正数和为1，第二步时正数和变为了2，将dp[1]修改为更大的2
总和为-1时，相比第一步时的正数和为0，第二步时正数和变为了1，将dp[-1]修改为更大的1
最后返回dp[0]


**正确代码如下**
```
class Solution:
    def tallestBillboard(self, rods):
        dp = {0: 0}
        for i in rods:
            for k, b in list(dp.items()):
                dp[k + i] = max(dp.get(k + i, 0), b + i)
                dp[k - i] = max(dp.get(k - i, 0), b)
        return dp[0]

```

---------
---------
---------
---------

**做题时候遇到的坑**
**以下为错误代码**
```python
# 我的代码如下，并不能ac，原因在于更新列表时候，要用最新的值（键要用老的）
class Solution:
    def tallestBillboard(self, rods):
        dp = {0: 0}
        for i in rods:
            dp1 = dp.copy()
            for k in list(dp1.keys()):
                dp[k - i] = max(dp1.get(k - i, 0), dp1[k])
                dp[k + i] = max(dp1.get(k + i, 0), dp1[k] + i)
            #print(dp)
            #print()
        return dp[0]

# 正确
print(Solution().tallestBillboard([1,2,3,6])) 
# 这个用例会错误
print(Solution().tallestBillboard([61, 45, 43, 54, 40, 53, 55, 47, 51, 59, 42])) 
```

> 原因在于第三次迭代的时候dp数组结果为{0: 0, -61: 0, 61: 61, -45: 0, 45: 45, **-106: 0**, -16: 45, 16: 61, **106: 106**, -43: 0, 43: 43, -104: 0, -18: 43, 18: 61, 104: 104, -88: 0, **-2: 43**, **2: 45**, 88: 88, -149: 0, -63: 43, -59: 45, 27: 88, -27: 61, 59: 104, 63: 106, 149: 149}

可以看到有个键-106,106在前面，这个时候第四次迭代的值是54，会更新键-52:54,52:106 考虑这个时候碰到键-2，2的时候则更新为52:106, -52:54
我没有考虑这个-106 106（因为用的老值），所以遇到-2，2的时候是第一次更新，变为52：97，-52：45然后就错了

```
# 在原有代码改一点就行了
class Solution:
    def tallestBillboard(self, rods):
        dp = {0: 0}
        for i in rods:
            # 浅拷贝和深拷贝请看https://www.cnblogs.com/alimy/p/10374923.html
            dp1 = dp.copy()
            for k in list(dp1.keys()):
                # 把这里的dp1改成了dp，那么获取的就是最新值啦~
                dp[k + i] = max(dp.get(k + i, 0), dp1[k] + i)
                dp[k - i] = max(dp.get(k - i, 0), dp1[k])
        return dp[0]
```

