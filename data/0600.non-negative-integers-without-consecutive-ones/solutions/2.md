## [600.不含连续1的非负整数 中文热门题解2](https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/solutions/100000/suan-fa-xiao-ai-wo-lai-gei-ni-jie-shi-qi-4nh4)

作者：[BNDSllx](https://leetcode.cn/u/BNDSllx)
> 大家好，我是小爱，一个热爱算法并不断努力的女孩子！[关注我](https://leetcode-cn.com/u/helen_class/)，和我一起交流算法心得呀！

## 前言
今天的官方题解可能有些难以理解，小爱今天就把官方题解给大家解释清楚。如果有问题，欢迎在评论区与小爱讨论呀~~~

## 解法：01字典树 + 动态规划
题目要求我们在 $[0, n]$ 之间所有数的**二进制表示**中进行答案搜索，我们可以自然而然的想到 01 字典树。01 字典树是什么呢？

### 1. 什么是字典树
> 以下参考：[OI Wiki字典树 (Trie)](https://oi-wiki.org/string/trie/)

字典树，英文名 trie。顾名思义，就是一个像字典一样的树。它可以做什么呢？顾名思义，这是起查找作用的一种树，可以在 $O(lgn)$ 的复杂度内查找给定的字符串（或者数字）是否存在。

例如，对于仅由 `a, b, c` 三种字母构成的部分字符串，其字典树如下：

![image.png](https://pic.leetcode-cn.com/1631320737-NNAboI-image.png)

可以发现，这棵字典树用边（或点）来代表字母，而从根结点到树上某一结点的路径就代表了一个字符串。举个例子， 表示的就是字符串 `caa`。

而官方题解中给出的 01 字典树，就是用点来代表 $0$ 或 $1$，从根节点到树上某一叶节点的路径，就代表了一个二进制表示的整数。例如，我们沿最右边的路径一直往下，得到的就是 $(110)_2$ ，也就是数字 $6$。

![image.png](https://pic.leetcode-cn.com/1631320906-ipzqwx-image.png)

---

### 2. 满二叉树的路径

题目要求我们找到所有 “其二进制表示不包含连续的1” 的数字，也就是说，在 $01$ 字典树的路径上，不能存在连续两个 $1$。这个问题本可以通过建树 + 搜索的方法解决，但是本题的数据范围为 $n \leq 10^9$，会超时，所以我们要考虑一种不用穷举的方式来解决本题。

我们以 $n = 6$ 为例，它的左右子树均不为空，所以左子树是一棵满二叉树。满二叉树上满足题意的节点个数是否有规律可循呢？

我们发现，对于高度为 $t$，根节点为 $0$ 的满二叉树中，其左右子树均是高度为 $t - 1$ 的满二叉树，只是根节点分别为 $0, 1$。**这是显而易见的子问题！！！** 我们考虑用 $dp[k][t]$ 表示根节点为 $k$，高度为 $t$ 的满二叉树中，满足题意的路径数量。那么就有：
$$
dp[0][t] = dp[0][t - 1] + dp[1][t - 1]
$$
我们另外发现，对于高度为 $t$，根节点为 $1$ 的满二叉树，其右子树的根节点也为 $1$，那么其右子树上的路径均不满足题意，因为已经有连续两个 $1$ 存在。所以，其路径数量仅仅取决于其左子树：
$$
dp[1][t] = dp[0][t - 1]
$$
将其代入上一个式子，我们便有：
$$
dp[0][t] = dp[0][t - 1] + dp[1][t - 1] = dp[0][t - 1] + dp[0][t - 2]
$$

综上所述！我们可以将高度为 $t$，根节点为 $0$ 的满二叉树路径缩小到一维表示，也就是官方题解的转移方程：
$$
d p[t]=\left\{\begin{array}{l}
d p[t-1]+d p[t-2], \quad t \geq 2 \\
1, \quad t<2
\end{array}\right.
$$

---

### 3. 非满二叉树的路径数量

如果一棵子树不是满二叉树，我们如何求解呢？

**如果该子树有右子树，说明其左子树是满二叉树**。而我们已经求出了满二叉树中的路径数量，直接考虑其右子树即可。同理，若该子树没有右子树，我们递归考虑其左子树即可。

由于我们无法建树搜索，所以在代码中，上述过程需要通过位运算来求解，我们借助官方题解这部分的代码来解释。

```C++
// pre 记录上一层的根节点值，res 记录最终路径数
int pre = 0, res = 0;
for (int i = 29; i >= 0; --i) {
    int val = 1 << i;
    // if 语句判断 当前子树是否有右子树
    if ((n & val) != 0) {
        // 有右子树
        n -= val;
        res += dp[i + 1]; // 先将左子树（满二叉树）的路径加到结果中

        // 处理右子树
        if (pre == 1) {
            // 上一层为 1，之后要处理的右子树根节点肯定也为 1
            // 此时连续两个 1，不满足题意，直接退出
            break;
        }
        // 标记当前根节点为 1
        pre = 1;
    } else {
        // 无右子树，此时不能保证左子树是否为满二叉树，所以要在下一层再继续判断
        pre = 0;
    }

    if (i == 0) {
        ++res;
    }
}
```

我们从高到低枚举不同位，实际上就是在 01 字典树中从高到低枚举高度。如果 `(n & val) != 0`，说明当前的 $n$ 形成的字典树有右子树，此时左子树为满二叉树，其路径数已经求出。我们直接递归求解右子树 ($n -= val$) 即可。

以 $n = 6$ 为例，当遍历到 $i = 2$ 时，便是判断是否有高度为 $2$ 的子树。此时计算得到的 $val = 4 = (100)_2$，由于 $n \& val = 100 != 0$，说明当前 $n = 6$ 的字典树是有右子树的。此时其左子树是高度为 $3$，根节点为 $0$ 的满二叉树，路径数为 $dp[3]$，其右子树就是图中红框的部分，实际就是 $n = 2$ 的 01 字典树，这可以通过 $n' = n - val$ 得到。

![image.png](https://pic.leetcode-cn.com/1631323849-pPQzdZ-image.png)

如果当前没有右子树，此时并不能判断左子树是否为满二叉树，要留到下一层继续判断。

---

## 代码：官方题解代码注释版

```C++ []
class Solution {
public:
    int findIntegers(int n) {
        // 预处理第 i 层满二叉树的路径数量
        vector<int> dp(31);
        dp[0] = dp[1] = 1;
        for (int i = 2; i < 31; ++i) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        // pre 记录上一层的根节点值，res 记录最终路径数
        int pre = 0, res = 0;
        for (int i = 29; i >= 0; --i) {
            int val = 1 << i;
            // if 语句判断 当前子树是否有右子树
            if ((n & val) != 0) {
                // 有右子树
                n -= val;
                res += dp[i + 1]; // 先将左子树（满二叉树）的路径加到结果中

                // 处理右子树
                if (pre == 1) {
                    // 上一层为 1，之后要处理的右子树根节点肯定也为 1
                    // 此时连续两个 1，不满足题意，直接退出
                    break;
                }
                // 标记当前根节点为 1
                pre = 1;
            } else {
                // 无右子树，此时不能保证左子树是否为满二叉树，所以要在下一层再继续判断
                pre = 0;
            }

            if (i == 0) {
                ++res;
            }
        }

        return res;
    }
};
```
```Java []
class Solution {
    public int findIntegers(int n) {
        // 预处理第 i 层满二叉树的路径数量
        int[] dp = new int[31];
        dp[0] = dp[1] = 1;
        for (int i = 2; i < 31; ++i) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        // pre 记录上一层的根节点值，res 记录最终路径数
        int pre = 0, res = 0;
        for (int i = 29; i >= 0; --i) {
            int val = 1 << i;
            // if 语句判断 当前子树是否有右子树
            if ((n & val) != 0) {
                // 有右子树
                n -= val;
                res += dp[i + 1]; // 先将左子树（满二叉树）的路径加到结果中

                // 处理右子树
                if (pre == 1) {
                    // 上一层为 1，之后要处理的右子树根节点肯定也为 1
                    // 此时连续两个 1，不满足题意，直接退出
                    break;
                }
                // 标记当前根节点为 1
                pre = 1;
            } else {
                // 无右子树，此时不能保证左子树是否为满二叉树，所以要在下一层再继续判断
                pre = 0;
            }

            if (i == 0) {
                ++res;
            }
        }

        return res;
    }
}
```
```Python3 []
class Solution:
    def findIntegers(self, n: int) -> int:
        # 预处理第 i 层满二叉树的路径数量
        dp = [0] * 31
        dp[0] = 1
        dp[1] = 1
        for i in range(2, 31):
            dp[i] = dp[i - 1] + dp[i - 2]

        # pre 记录上一层的根节点值，res 记录最终路径数
        pre = 0
        res = 0

        for i in range(29, -1, -1):
            val = (1 << i)
            # if 语句判断 当前子树是否有右子树
            if n & val:
                # 有右子树
                n -= val
                res += dp[i + 1] # 先将左子树（满二叉树）的路径加到结果中
                if pre == 1:
                    # 上一层为 1，之后要处理的右子树根节点肯定也为 1
                    # 此时连续两个 1，不满足题意，直接退出
                    break
                pre = 1
            else:
                # 无右子树，此时不能保证左子树是否为满二叉树，所以要在下一层再继续判断
                pre = 0

            if i == 0:
                res += 1

        return res
```