## [1494.并行课程 II 中文热门题解2](https://leetcode.cn/problems/parallel-courses-ii/solutions/100000/cchao-qing-xi-de-si-lu-chao-xiang-xi-de-zqs3i)

作者：[Mountain-Ocean](https://leetcode.cn/u/Mountain-Ocean)

# 预备知识
首先分享一些状态压缩常用的操作，掌握这些技巧，基本上可以应付leetcode上大部分和状态压缩有关的题目
```
for (int i = 0; i < totalState; ++i) {
    cnt[i] = cnt[i >> 1] + (i & 1);
}
```
批量统计```i```的二进制数中```1```的个数

---------------------------------------------------------------------------------------------------------------
```
bitset<32>(num).count()
```

统计单个数```num```的二进制数中```1```的个数，```32```可以为其他数，取决于```num```的二进制数长度

---------------------------------------------------------------------------------------------------------------
```
for (int subMask = state; subMask; subMask = (subMask - 1) & state) {
    operate subMask...
}
```
遍历```state```的子集，比如```state```是```011```，那么子集是```{001, 010, 011}```

---------------------------------------------------------------------------------------------------------------

```
int lowBit = a & -a
```
取```a```的最低位```1```，比如```a = 00110100```，则```lowBit = 100```，原理是一个数的负数是它的**反码加1**，即从右到左数(低位到高位)保留第一个1，其他都取反。这样一个正数与它对应负数进行```&```操作后，就只保留了低位的1了

---------------------------------------------------------------------------------------------------------------

```
(x & y) == x 
```
判断```x```是否是```y```的子集，表达式为```true```的话，说明```x```是```y```的子集，一个小技巧, 不用费力记公式, 实际用的时候，可以现场推导，比如```x = 0110```, ```y = 1111```, 由于```0110 & 1111 = 0110```, 所以```x & y = x```

---------------------------------------------------------------------------------------------------------------

```
(x & (x >> 1)) == 0
```
判断```x```的二进制数中是否有**连续**的```1```，表达式为```true```的话，说明没有

---------------------------------------------------------------------------------------------------------------

```
1 & (x >> i)
```

判断```x```的二进制数中，第```i```位是否是```1```，从左到右数

---------------------------------------------------------------------------------------------------------------


# 思路
**在上过某些课程的前提下**，选出满足**约束条件**的课程，在本学期上，约束条件为：
- **课程之前没上过**
- **课程的先修课已经全部都上完了**

详细解释见代码注释

```
class Solution {
public:
    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {
        vector<int> prerequisite(n, 0);
        for (const auto& pair : relations) {
            int pre = pair[0] - 1;
            int after = pair[1] - 1;
            // 举例：prerequisite[1] = 0110 表示1的先修课为2和3
            prerequisite[after] |= 1<<pre;
        }

        int totalState = 1 << n;
        vector<int> dp(totalState, 16);
        // 0为不需要上任何课的状态，因此不需要学期
        dp[0] = 0;

        vector<int> cnt(totalState);
        cnt[0] = 0;
        // 小技巧，计算每个数字的二进制数中，1的个数
        for (int i = 1; i < totalState; ++i) {
            cnt[i] = cnt[i>>1] + (i&1);
        }

        // taken表示已经上过的课，假设taken = 0111，表示课程1 2 3已经上过了
        for (int taken = 0; taken < totalState; ++taken) {
            if (dp[taken] > n) continue;
            int cur = 0;
            // 在上过taken的基础上，还有哪些课可以上，要满足两个条件
            // 1. ((taken & (1 << j)) == 0) 表示这个课在taken中没上过
            // 2. ((prerequisite[j] & taken) == prerequisite[j]) 表示这个课的先修课已经上完了
            for (int j = 0; j < n; ++j) {
                if (((taken & (1 << j)) == 0) && ((prerequisite[j] & taken) == prerequisite[j])) {
                    // 存这学期可以上的课，注意，可以上不代表一定要上，也不一定要上满，这题的本质是NPC问题，任何贪心的思想都是错的，选择cur中的课来上的这个操作，用下面枚举子集的方法实现
                    cur |= (1 << j);
                }
            }
            // 枚举cur的子集，比如cur = 111，它的子mask集合就是{111, 110, 101 011, 100, 010, 001}
            for (int subMask = cur; subMask != 0; subMask = subMask-1 & cur) {
                // 这学期上的课的数量不能超过k
                if (cnt[subMask] <= k) {
                    // 之前上完taken，这学期再上subMask，看看会不会更好
                    dp[taken|subMask] = min(dp[taken|subMask], dp[taken] + 1);
                }
            }
        }
        
        return dp[totalState - 1];
    }
};
```

**注意**：这里选出的课不一定要全上。因为这道题本质上是NP完全问题，任何贪心的思想都是错的，而状态压缩本质上是一种穷举所有情况的**暴力算法**，只能处理**小规模**问题。
(题外话：这其中的重要性，举个例子，如果能提出正确的贪心解法或者多项式时间解法，意味着**NP = P**，即**任意能在多项式时间内被验证的问题都有多项式时间的解法**，毫不夸张地说，别提下一届的图灵奖、菲尔茨奖非你莫属，地球上的国家为了争夺你可能会爆发世界大战，人类文明会迈入下一个台阶，牛顿高斯爱因斯坦见到你都得点头哈腰叫声大哥或女神，^_^)
感兴趣的同学可以网上搜下这篇论文:J.D.Ullman, NP-complete scheduling problems. 关于这类问题是NPC的证明(美版leetcode找的)

**看到这里，如果有收获，能给一个赞，那将是对我最大的鼓励啦^_^**