## [1846.减小和重新排列数组后的最大元素 中文热门题解1](https://leetcode.cn/problems/maximum-element-after-decreasing-and-rearranging/solutions/100000/gong-shui-san-xie-noxiang-xin-ke-xue-xi-yh9qt)

作者：[AC_OIer](https://leetcode.cn/u/AC_OIer)
## 基本分析 & 证明

根据题意，数组的第一位必须是 $1$，且每个数只能 **减小** 或 **不变**，数值位置可以任意调整。

求解经过调整后，符合要求的数组中的最大值是多少。

首先符合条件的数组相邻位差值绝对值不超过 $1$，这限定了数组的必然是如下三种分布之一：

* （非严格）单调递减
* 存在波段
* （非严格）单调递增

**证明一：取得最优解对应的数组「必然是」或者「可调整为」（非严格）单调递增的形式。**

我们使用反证法来证明另外两种分布不能取得最优解：

* （非严格）单调递减：题目限定了数的范围为正整数，且第一位为 $1$，这种情况不用讨论了，跳过；
* 存在波段：我们始终可以将波峰的右侧出现的值，纳入到波峰的左侧，从而消掉这个波峰，最终将整个分布调整为「（非严格）单调递增」的形式，结果不会变差：

![image.png](https://pic.leetcode-cn.com/1626313722-UOzMRP-image.png)

多个波段的情况也是同理，可以自己在纸上画画。

都是利用 **波峰右侧的点可以调整成波峰左侧的点，从而使分布变为（非严格）单调递增。**

**至此，我们证明了最优解对应的数组必然符合（非严格）单调递增。**

这启发我们可以先对原数组排个序，在此基础上进行分析。

对原数组排序得到的有序数组，不一定是符合「相邻位差值绝对值不超过 $1$」的，同时由于每个数值可以选择 **减小** 或 **不变**。

**证明二：当必须要对当前位进行调整的时，优先选择调整为「与前一值差值为 $1$ 的较大数」不会比调整为「与前一差值为 $0$ 的较小数」更差。**

这可以使用归纳推理，假设采取「优先调整为与前一值差值为 $1$ 的较大数」得到的序列为 `a`，采用「优先调整与前一差值为 $0$ 的较小数」得到的序列为 `b`。

**根据「$a[0] = b[0] = 1$」、「`a` 和 `b` 长度一致」、「`a` 和 `b` 均为（非严格）单调递增」以及「`a` 和 `b` 均满足相邻位差值不超过 $1$」，可推导出 $sum(a) >= sum(b)$，和任意位置 $a[i] >= b[i]$，从而推导出 `a` 序列的最后一位必然大于等于 `b` 的最后一位。**

即 `b` 不会比 `a` 更优。

**证明三：调整大小的操作不会改变数组元素之间的相对位置关系。**

在证明二的分析中，我们会对某些元素进行“减小”操作，使得整个数组最终满足「相邻位差值绝对值不超过 $1$」。

但该证明成立的还有一个很重要的前提条件，就是调整操作不会出发元素的位置重排。

那么该前提条件是否必然成立呢？答案是必然成立。

假设原排序数组中存在需要调整的点 $i$ 和点 $j$，且 $nums[i] <= nums[j]$。

为了让数组满足条件，它们都进行了“减少”操作的调整，分别变为了 $p$ 和 $q$，如果触发位置重排的话，必然有 $nums[p] >= nums[q]$。

此时，我们能够通过调整它们的变化关系：点 $i$ 变为点 $q$、点 $j$ 变成点 $p$ 来确保同样满足条件，且不触发元素在有序数组中的位置重排。

![image.png](https://pic.leetcode-cn.com/1626316820-JbzSUo-image.png)


---

## 贪心

排序，限定第一位值为 $1$，从前往后处理，根据每一位是否「必须修改（与上一位差值是否大于 $1$）」做决策，如果必须被修改，则修改为与前一值差值为 $1$ 的较大数。

代码：
```Java []
class Solution {
    public int maximumElementAfterDecrementingAndRearranging(int[] arr) {
        int n = arr.length;
        Arrays.sort(arr);
        arr[0] = 1;
        for (int i = 1; i < n; i++) {
            if (arr[i] - arr[i - 1] > 1) {
                arr[i] = arr[i - 1] + 1;
            }
        }
        return arr[n - 1];
    }
}
```
* 时间复杂度：假定 `Arrays.sort` 使用的是双轴快排实现。复杂度为 $O(n\log{n})$
* 空间复杂度：假定 `Arrays.sort` 使用的是双轴快排实现。复杂度为 $O(\log{n})$

---

## 最后

**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ ("▔□▔)/**

也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png) 和 加入我们的[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解。

所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~ 