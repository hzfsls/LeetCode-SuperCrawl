## [861.翻转矩阵后的得分 中文热门题解1](https://leetcode.cn/problems/score-after-flipping-matrix/solutions/100000/fan-zhuan-ju-zhen-tan-xin-xin-lu-li-chen-21h7)

作者：[sweetiee](https://leetcode.cn/u/sweetiee)

### 题目描述

给定二维 01 数组，任意翻转某些行/列，使得矩阵每行表示的十进制数的和最大。

### 思(xin)路解(li)析(cheng)

题目要求每行表示的数的和最大，那么我们很容易就想到可以让每行表示的数尽可能的大。由于每行为一个二进制数，那么我们肯定希望所有位置都尽可能为 1，尤其是数字的高位，最好就是 1。我们通过观察样例发现，每行的第一个数字都为 1。我们想下，的确不论如何翻转，第一列全为 1的结果一定大于其它任何结果的。所以我们先把最高位为 0 的行翻转，并且那些最高位为 1 的是不能行翻转的。对于样例 1，进行如下的变换：

```
0011
1010
1100

变为

1100
1010
1100

（只有第一行操作了行翻转）
```

好的，我们再去考虑列翻转。对于每列，我们肯定希望 1 越多越好，因为每个 1 都会让那行的数字更大。那么统计每列中 0 和 1 的个数，如果 0 多就列翻转，否则不列翻转。对于样例 1，变换继续：


```
1100
1010
1100

变为

1111
1001
1111

（第三列第四列操作了列翻转）
```

然后这题就结束了（贪心完了）。

### 代码实现

直接按上述思路实现即可。如果追求短代码更高效率，2 个 $O(n^2)$ 的循环是可以合并起来的，不需要行翻转直接统计每列的 0 或 1 个数，方法就是如果 A[i][0] 为 0，A[i][j] 的值翻转一下，具体写法可以自己尝试一下。

``` java
class Solution {
  public int matrixScore(int[][] A) {
    int m = A.length, n = A[0].length;
    int result = 0;
    for (int i = 0; i < m; i++) {
      // 如果第 i 行以 0 开头
      if (A[i][0] == 0) {
        // 行翻转
        for (int j = 0; j < n; j++) {
          A[i][j] ^= 1;
        }
      }
    }
    for (int j = 0; j < n; j++) {
      int cnt = 0;
      // 统计第 j 列有多少个 1。
      for (int i = 0; i < m; i++) {
        cnt += A[i][j];
      }
      // max(cnt, m - cnt) 表示这个位置最多有多少个 1。 1<<(n-j-1) 表示这个位置的1的大小。
      result += Math.max(cnt, m - cnt) * (1 << (n - j - 1));
    }
    return result;
  }
}
```

----

💖 公主号「甜姨的奇妙冒险」，[戳这里](https://sweeetiee-1256505723.cos.ap-beijing.myqcloud.com/sweetiee_wechat.jpeg)。 💖 知乎专栏「甜姨的力扣题解」，[戳这里](https://zhuanlan.zhihu.com/c_1224355183452614656)。快到碗里来～