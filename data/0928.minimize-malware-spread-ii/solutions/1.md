## [928.尽量减少恶意软件的传播 II 中文热门题解1](https://leetcode.cn/problems/minimize-malware-spread-ii/solutions/100000/bing-cha-ji-mo-ban-by-yexiso-w7t9)

作者：[yexiso](https://leetcode.cn/u/yexiso)

# 题目
![image.png](https://pic.leetcode-cn.com/1612597166-oDpPZa-image.png)


# 前言

**这里需要说明一下：**
>**下文中所说的 “上题” 是指：[924. 尽量减少恶意软件的传播](https://leetcode-cn.com/problems/minimize-malware-spread/)
>因为两题思路大致相同，所以放在一起讲解。**

**另外：**

> 如果您对【**并查集**】相关知识还不是太了解，可以看看本人之前的相关讲解[【详解并查集】](https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/solution/tu-jie-bing-cha-ji-by-yexiso-nbcz/)
> 如果有任何问题，欢迎留言交流！



# 方法一：万能模版


### 1）解题思路

- 本题与[上题](https://leetcode-cn.com/problems/minimize-malware-spread/)大同小异，只是对“删除节点”的解释不同。

- 上题中，只删除节点的【被感染状态】，不删除其他任何要素。

- 而本题，不仅删除节点的【被感染状态】，同时删除其与其他节点的连接关系，也就是破坏了其所处连通子图内部的连接关系。

> 没做过的可以先尝试[上题](https://leetcode-cn.com/problems/minimize-malware-spread/)，以及之前的题解[【并查集解法】](https://leetcode-cn.com/problems/minimize-malware-spread/solution/bing-cha-ji-by-yexiso-mnog/)

### 2）万能模版

此类问题有一个万能方法 -- 请看[【重构并查集】](https://leetcode-cn.com/problems/minimize-malware-spread/solution/bing-cha-ji-by-yexiso-mnog/)

> 1. 我们遍历 `initial` 中的每个感染节点 `i`
> 2. 在图 `graph` 中将该节点以及其相关连接删除，形成的新图记作 `graphNew`
> 3. 对图`graphNew`中的连接关系构造并查集，并判断最终会有多少个节点被感染，记作 `M`
> 4. 重复步骤 1 - 3， 返回产生最少的被感染节点数 `minM`的对应删除节点

该方法唯一的不足就是，每遍历一个待删除点，便需要重构一次并查集。


> - **问**：为什么说这是万能模版？
> - **答**：因为对于类似的问题，涉及到【连通性、删除节点、添加节点后的状态】，我们都可以采用模拟的方法，也就是删除/增加节点之后再行判断。

所以，如果用【万能模版】的思路来考虑，本题与[上题](https://leetcode-cn.com/problems/minimize-malware-spread/)几乎完全一样，**只是在删除节点后，新图graphNew的构造过程（并查集的重构过程）稍有不同**。
```
    // 1. 上题的重构过程
    // 根据graphNew，重构并查集
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (graph[i][j] == 1) ds.merge(i, j);
        }
    }

    // 2. 本题的重构过程
    // 根据graphNew，重构并查集
    for (int i = 0; i < n; i++) {
        if (i == e) continue;
        for (int j = i + 1; j < n; j++) {
            if (j == e) continue;
            if (graph[i][j] == 1) ds.merge(i, j);
        }
    }
```
从代码中可以看出，本题在重构并查集的过程中，添加了 `if (i == e) continue;` 和 `if (i == e) continue;`的限制，这是为了去掉删除节点与其他节点之间的连接关系。

### 3）代码

具体请看完整代码：

```cpp
// 比较常规的并查集模版
class DJset {
public:     
    vector<int> parent;
    vector<int> rank;
    vector<int> size;

    DJset(int n): parent(n), rank(n), size(n, 1) {
        for (int i = 0; i < n; i++) {
            parent[i] = i;   
        }
    }

    int find(int x) {
        if (x != parent[x]) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    void merge(int x, int y) {
        int rx = find(x);
        int ry = find(y);
        if (rx != ry) {
            if (rank[rx] < rank[ry]) swap(rx, ry);
            parent[ry] = rx;
            size[rx] += size[ry];
            size[ry] = 0;
            if (rank[rx] == rank[ry]) rank[rx] += 1;
        }
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        sort(initial.begin(), initial.end());
        int minM = n;
        int idx = initial[0];

        // 在删除i节点的条件下，有多少个节点被感染
        for (auto& e : initial) {
            int M = 0;
            DJset ds(n);
            // 与I题相比，仅此处不同
            for (int i = 0; i < n; i++) {
                if (i == e) continue;
                for (int j = i + 1; j < n; j++) {
                    if (j == e) continue;
                    if (graph[i][j] == 1) ds.merge(i, j);
                }
            }
            unordered_set<int> ust;
            for (auto& i : initial) {
                int ri = ds.find(i);
                if (ust.count(ri)) continue;
                ust.insert(ri);
                M += ds.size[ri];
            }
            if (M < minM) {
                minM = M;
                idx = e;
            }
        }

        return idx;
    }
};
```


# 方法二：逆向思维

### 1）前言

**问：本题为什么不能用[上题](https://leetcode-cn.com/problems/minimize-malware-spread/)题解[【并查集解法】](https://leetcode-cn.com/problems/minimize-malware-spread/solution/bing-cha-ji-by-yexiso-mnog/)中的方法二呢？**

**答：因为在本题中，当删除一个感染节点之后，与其相连的边也会跟着删除，这样原本的一个连通分量可能因此而一分为二，这样原本的连通分量中的感染节点数可能产生变化，所以单单通过连通分量中的感染节点数来判断，对于本题是不够的。**

> 提到 **拆分** 连通图，是否还记得[打砖块](https://leetcode-cn.com/problems/bricks-falling-when-hit/)那道题，我们之前提过可以采用[【逆向并查集】](https://leetcode-cn.com/problems/bricks-falling-when-hit/solution/bing-cha-ji-by-yexiso-cp6z/)。因为并查集本身只适合用作集合的合并，并不适合用作集合的拆分
> 当碰到拆分 并查集的题干，应该想到 **逆向思维** 地利用并查集
> 当然，本题也不例外

这样，我们采用逆向思维并结合本题的背景，将问题由**删除一个感染节点能减少多个节点受到感染**转换成**添加一个感染节点会增加多少个被感染节点**，具体看下推理过程：

> **推理过程：**
> 题目说了 删除一个节点要使得最后的被感染节点数最少，所以，删除这个节点之后，该节点能帮我们恢复正常的节点应该尽可能多。
> 意思是说，要找出一个感染节点，仅仅受到该节点感染的正常节点数 相对于 仅仅受到其他感染节点影响的节点数 最多。
> **逆向思考，即添加一个感染节点，使得该节点能感染的节点最多。**


### 2）步骤

> 1. 忽略所有感染节点，只考虑正常节点。针对所有正常节点之间的连接关系，构建初始并查集 `ds`（此时并查集中的所有连通分量均未受到感染）
> 2. 依次遍历感染节点数组  `initial` ，当判断到节点 `i` 时， 计算初始并查集 `ds` 中有哪些连通分量只与感染节点i相连，不与其他任何感染节点相连。计算满足条件的所有连通分量的节点数之和 `counts`，加入到数组 `infectNums`中。
> 3. 遍历 `infectNums` ，找出最大值，返回节点编号

### 3）例子

通过一个例子来加深理解

<![幻灯片1.png](https://pic.leetcode-cn.com/1612192590-hJBIng-%E5%B9%BB%E7%81%AF%E7%89%871.png),![幻灯片2.png](https://pic.leetcode-cn.com/1612192595-FArTvY-%E5%B9%BB%E7%81%AF%E7%89%872.png),![幻灯片3.png](https://pic.leetcode-cn.com/1612192601-gFKkDC-%E5%B9%BB%E7%81%AF%E7%89%873.png),![幻灯片4.png](https://pic.leetcode-cn.com/1612192606-ZFdlFH-%E5%B9%BB%E7%81%AF%E7%89%874.png)>
 
图片请配合代码来观看！

### 4）代码
```
// 比较常规的并查集模版
class DJset {
public:     
    vector<int> parent; 
    vector<int> rank;
    vector<int> size;

    DJset(int n): parent(n), rank(n), size(n, 1) {
        for (int i = 0; i < n; i++) {
            parent[i] = i;   
        }
    }

    int find(int x) {
        if (x != parent[x]) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    void merge(int x, int y) {
        int rx = find(x);
        int ry = find(y);
        if (rx != ry) {
            if (rank[rx] < rank[ry]) swap(rx, ry);
            parent[ry] = rx;
            size[rx] += size[ry];
            size[ry] = 0;
            if (rank[rx] == rank[ry]) rank[rx] += 1;
        }
    }
};

class Solution {
public:
    // 说明： 感染节点 意为 initial 中的节点
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        sort(initial.begin(), initial.end());
        int maxM = -1;         // 记录最少感染节点数
        int idx = initial[0]; // 记录产生最少感染节点数的 删除节点

        DJset ds(n);
        // 先对所有正常节点， 构建并查集
        for (int i = 0; i < n; i++) {
            if (count(initial.begin(), initial.end(), i)) continue;
            for (int j = i + 1; j < n; j++) {
                if (count(initial.begin(), initial.end(), j)) continue;
                if (graph[i][j] == 1) ds.merge(i, j);
            }
        }

        // infectRoot ： 记录 感染来源 个数
        // 主要记录连通分量的感染来源，此处只有 并查集连通分量中的根节点存在值，其他下标均为 -1
        // -1 ：该下标出节点不是连通分量根节点
        // -2 ：该下标处节点为连通分量根节点，但有 多 个感染来源
        // 其他值 ： 该下标处节点为连通分量，且该连通分量只有 1 个感染来源
        vector<int> infectRoot(n, -1);
        for (auto& i : initial) {
            for (int j = 0; j < n; j++) {
                if (count(initial.begin(), initial.end(), j)) continue;
                int rj = ds.find(j);
                if (graph[i][j] == 0 || infectRoot[rj] == -2) continue;
                if (infectRoot[rj] == -1) {
                    infectRoot[rj] = i;
                } else if(infectRoot[rj] != i) {
                    // 如果本连通分量已存在感染源，且感染源不是节点i
                    // 说明该分量存在了多个不同的感染源
                    infectRoot[rj] = -2;
                }
            }
        }

        // infectNums ： 记录每个 感染节点 能感染的节点数
        vector<int> infectNums(n);
        for (int i = 0; i < n; i++) {
            if (infectRoot[i] == -1 || infectRoot[i] == -2) continue;
            infectNums[infectRoot[i]] += ds.size[i];
        }

        for (auto& i : initial) {
            if (infectNums[i] > maxM) {
                maxM = infectNums[i];
                idx = i;
            }
        }
        return idx;
    }
};
```



# 总结


方法二相对于方法一，省去了并查集的合并，节省了大量时间。
因此方法二的效率要比方法一快很多，大家可以用数据测试一下。





经过这么多题的洗礼，我想我们再遇到集合拆分的题，第一反应可以是**逆向并查集**了！



> 谢谢您的观看，如果有任何问题，欢迎留言交流！