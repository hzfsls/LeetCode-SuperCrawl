## [629.K 个逆序对数组 中文热门题解2](https://leetcode.cn/problems/k-inverse-pairs-array/solutions/100000/tong-ge-lai-shua-ti-la-yi-ti-wu-jie-bao-ej4ym)

作者：[tong-zhu](https://leetcode.cn/u/tong-zhu)

今天是我坚持写题解的第 99 天！

# 方法一、暴力

今天这道题的难点在于递推公式的推导过程，我们来详细看一下。

我们的目标是要求得前 n 个数的数组中正好有 k 个逆序对的数量，那么，我们可以思考一下，**这个结果能否从前 n-1 个数的数组中转移过来？**

因为第 n 个数（即 n）肯定比前 n-1 个数大，所以，我们可以把数字 n 插入到 0~n-1 的不同位置：

- 假如前 n-1 个数的数组中正好有 k 个逆序对，那么，我们可以把 n 插入到这个数组的最后一位，得到的新数组正好也是 k 个逆序对，因为，新插入的 n 不会与任何数字组成逆序对，而原来数组中的逆序对保持不变；
- 假如前 n-1 个数的数组中正好有 k-1 个逆序对，那么，我们可以把 n 插入到这个数组的倒数第二位，这样，我们会得到 1 个新的逆序对，即原数组的最后一位与 n 组成的逆序对，而原来数组中的 k-1 个逆序对保持不变，总共会有 k 个逆序对；
- 假如前 n-1 个数的数组中正好有 k-2 个逆序对，那么，我们可以把 n 插入到这个数组的倒数第三位，这样，我们会得到 2 个新的逆序对，即原数组的最后两位与 n 组成的逆序对，而原来数组中的 k-2 个逆序对保持不变，总共会有 k 个逆序对；
- ...
- 假如前 n-1 个数的数组中正好有 0(k-k) 个逆序对，那么，我们可以把 n 插入到这个数组的倒数第 k+1 位，这样，我们会得到 k 个新的逆序对，即原数组的最后 k 位与 n 组成的逆序对，而原来数组中的 0 个逆序对保持不变，总共会有 k 个逆序对；

所以，我们可以得出递推公式为：$f(n)(k)=f(n-1)(k)+f(n-1)(k-1)+...+f(n-1)(0)$。

我们来举个例子帮助理解。

假如给定 `n=4,k=2`，即我们要求解给定 [1,2,3,4] 四个数缓存的数组中恰好有 2 个逆序对的数组的个数，我们用 f(4)(2) 来表示，求解过程如下：

- 求解 f(3)(2)，而 f(3)(2) 我们动动手指会发现有两种情况，[3,1,2] 和 [2,3,1]，我们把 4 加到这两个数组的最后一位，形成新的数组 [3,1,2,4] 和 [2,3,1,4]，正好是有两个逆序对的，因为 4 的加入并没有提供新的逆序对；
  ![image-20211111141854056](https://pic.leetcode-cn.com/1636616826-gFoxUC-file_1636616826834)
- 求解 f(3)(1)，而 f(3)(1) 我们动动手指会发现有两种情况，[1,3,2] 和 [2,1,3]，我们把 4 加到这两个数组的倒数第二位，形成新的数组 [1,3,4,2] 和 [2,1,4,3]，正好是有两个逆序对的，因为 4 的加入正好各提供了一个新的逆序对；
  ![image-20211111142340402](https://pic.leetcode-cn.com/1636616826-bsLSSb-file_1636616826789)
- 求解 f(3)(1)，而 f(3)(0) 我们动动手指会发现有一种情况，[1,2,3]，我们把 4 加到这两个数组的倒数第三位，形成新的数组 [4,1,2,3]，正好是有两个逆序对的，因为 4 的加入正好提供了两个新的逆序对；
  ![image-20211111142526202](https://pic.leetcode-cn.com/1636616826-PVjrfy-file_1636616826793)

所以，f(4)(2) = f(3)(2) + f(3)(1) + f(3)(0) = 2 + 2 + 1 = 5。

好了，上面的过程你能看懂，那就没问题了，我们再来看看边界的问题。

第一个边界，上面描述中的倒数第 x 位，不能超过原数组的下标 0，所以，假设前 n-1 个数中正好有 k-i 个逆序对，这个 k-i 必须小于等于 n-1，即 i >= k-n+1，这个等会看代码中有用到。

第二个边界，对于 n 个数组成的数组最多有多少个逆序对？这种情况对应到所有数倒序排列，那么，对于 n 来说有 n-1 个逆序对，对于 n-1 来说有 n-2 个逆序对，...，对于 1 来说没有逆序对，所以，最多有 (n-1) + (n-2) + ... + 0 = n(n-1)/2。所以，对于 k 大于 n(n-1)/2 的输入直接返回 0。

好了，我们来尝试写一下代码吧，先从暴力开始。

请看代码：

```java
class Solution {

    int MOD = 1000000007;

    public int kInversePairs(int n, int k) {
        return (int) (dfs(n, k) % MOD);
    }

    private long dfs(int n, int k) {
        if (k > n * (n - 1) / 2) {
            return 0;
        }
        if (n == 1) {
            return k == 0 ? 1 : 0;
        }

        long ans = 0;
        // 比如，求解 f(3)(3)，求解 f(2)(0) 是没有意义的，因为两个数的数组没有倒数第三位
        for (int i = Math.max(0, k - n + 1); i <= k; i++) {
            ans += dfs(n - 1, i);
        }

        return ans % MOD;
    }
}
```

- 时间复杂度：$O(k^n)$​​，这其实是一颗 k 叉对，第一层 1 个节点，第二层 $k$​ 个节点，第三层 $k^2$​ 个节点，...，最后一层 $k^n$​ 个节点，所以，总的计算量为 $S = k^0 + k^1 + k^2 + ... + k^n$​，两边乘以 k 相减，可得 $S = (k^{n+1}-1)/(k-1)$​​。
- 空间复杂度：O(nk)，每一次递归会申请 k 个临时变量存储 dfs 的结果，一共有 n 层递归。

运行结果如下，可以看到通过了 34 个用例，说明我们的思路没有问题，下面就是怎么优化的事儿了：

![image-20211111143637507](https://pic.leetcode-cn.com/1636616826-igjyvz-file_1636616826603)

# 方法二、记忆化搜索

方法一中其实是存在大量重复计算的，比如计算 f(3)(2) 会先计算 f(2)(0)，而计算 f(3)(1) 时也会先计算 f(2)(0)，所以，我们可以把 f(2)(0) 的计算结果缓存下来，这就是记忆化搜索。

请看代码：

```java
class Solution {

    int MOD = 1000000007;

    public int kInversePairs(int n, int k) {
        long[][] memo = new long[n + 1][k + 1];
        for (int i = 0; i <= n ; i++) {
            Arrays.fill(memo[i], -1);
        }
        return (int) (dfs(n, k, memo) % MOD);
    }

    private long dfs(int n, int k, long[][] memo) {
        if (k > n * (n - 1) / 2) {
            return 0;
        }
        if (n == 1) {
            return k == 0 ? 1 : 0;
        }

        if (memo[n][k] != -1) {
            return memo[n][k];
        }

        long ans = 0;
        for (int i = Math.max(0, k - n + 1); i <= k; i++) {
            ans += dfs(n - 1, i, memo);
        }

        memo[n][k] = ans = ans % MOD;

        return ans;
    }
}
```

- 时间复杂度：$O(nk^2)$，一共有 $n*k$ 个状态，每个状态只会计算k次。
- 空间复杂度：$O(nk)$，递归层级为 n ，每次递归需要申请 k 个临时变量。

运行结果如下，可以通过：

![image-20211111145428067](https://pic.leetcode-cn.com/1636616826-LhOJAE-file_1636616826832)

# 方法三、动态规划

有了上面的记忆化搜索，相信转成动态规划不是问题了，我们一起来看看：

- 状态定义：`dp[i][j]` 表示前 i 个数的数组中正好有 j 个逆序对的个数；
- 状态转移：`dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + ... + dp[i-1][j-i-1]`；
- 初始值：`dp[1][0]=1`；
- 返回值：`dp[n][k]`；

同样地，需要注意边界问题。

请看代码：

```java
class Solution {

    int MOD = 1000000007;

    public int kInversePairs(int n, int k) {
        long[][] dp = new long[n + 1][k + 1];
        dp[1][0] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 0; j <= Math.min(k, i * (i - 1) / 2); j++) {
                for (int x = Math.max(0, j - i + 1); x <= j; x++) {
                    dp[i][j] = (dp[i][j] + dp[i - 1][x]) % MOD;
                }
            }
        }

        return (int) dp[n][k];
    }
}
```

- 时间复杂度：$O(nk^2)$。
- 空间复杂度：$O(nk)$。

运行结果如下，勉强通过，要想办法优化：

![image-20211111150526602](https://pic.leetcode-cn.com/1636616826-QevPzg-file_1636616826830)

# 方法四、优化时间

通过方法四，我们已知：

- `dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + ... + dp[i-1][j-(i-1)]`
- 同样地，`dp[i][j-1] = dp[i-1][j-1] + ... + dp[i-1][j-1-(i-1-1)] + dp[i-1][j-1-(i-1)]`

上面的公式减下面的公式可得：`dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-i]`。

请看代码：

```java
class Solution {

    int MOD = 1000000007;

    public int kInversePairs(int n, int k) {
        // dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + ... + dp[i-1][j-i-1]
        // dp[i][j-1] =            dp[i-1][j-1] + ... + dp[i-1][j-1-(i-1-1)] + dp[i-1][j-1-i-1]
        // dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1-i-1]

        long[][] dp = new long[n + 1][k + 1];
        dp[1][0] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 0; j <= Math.min(k, i * (i - 1) / 2); j++) {
                // dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1-i-1]
                dp[i][j] = ((j >= 1 ? dp[i][j - 1] : 0) + dp[i - 1][j] - (j >= i ? dp[i - 1][j - i] : 0) + MOD) % MOD;
            }
        }

        return (int) dp[n][k];
    }
}
```

- 时间复杂度：$O(nk)$​。
- 空间复杂度：$O(nk)$。

运行结果如下，可以看到，时间一下就提上去了：

![image-20211111153754065](https://pic.leetcode-cn.com/1636616826-atHSAI-file_1636616826610)

# 方法五、压缩空间

方法四中，可以看到公式 `dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-i]` 只与 i-1 项有关，所以，我们可以使用一个二维数组来交替使用降低空间复杂度。

请看代码：

```java
class Solution {

    int MOD = 1000000007;

    public int kInversePairs(int n, int k) {
        // dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + ... + dp[i-1][j-i-1]
        // dp[i][j-1] =            dp[i-1][j-1] + ... + dp[i-1][j-1-(i-1-1)] + dp[i-1][j-1-i-1]
        // dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1-i-1]

        long[][] dp = new long[2][k + 1];
        dp[1][0] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 0; j <= Math.min(k, i * (i - 1) / 2); j++) {
                // dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1-i-1]
                dp[i & 1][j] = ((j >= 1 ? dp[i & 1][j - 1] : 0) + dp[(i - 1) & 1][j] - (j >= i ? dp[(i - 1) & 1][j - i] : 0) + MOD) % MOD;
            }
        }

        return (int) dp[n & 1][k];
    }
}
```

- 时间复杂度：$O(nk)$​。
- 空间复杂度：$O(k)$​。

运行结果如下，可以看到，空间打败了 97% 的用户，哈哈：

![image-20211111154212408](https://pic.leetcode-cn.com/1636616826-qQqcID-file_1636616826833)

# 最后

**如果对你有帮助，请点个赞吧，谢谢^^**

也可以[关注我](https://leetcode-cn.com/u/tong-zhu/)（公号：彤哥来刷题啦），每日分享题解，一起刷题，一起拿全家桶。