## [765.情侣牵手 中文热门题解1](https://leetcode.cn/problems/couples-holding-hands/solutions/100000/liang-chong-100-de-jie-fa-bing-cha-ji-ta-26a6)

作者：[AC_OIer](https://leetcode.cn/u/AC_OIer)

## 并查集

![image.png](https://pic.leetcode-cn.com/1613291147-hfyqtT-image.png)

首先，我们总是以「情侣对」为单位进行设想：

1. 当有两对情侣相互坐错了位置，ta们两对之间形成了一个环。需要进行一次交换，使得每队情侣独立（相互牵手）

2. 如果三对情侣相互坐错了位置，ta们三对之间形成了一个环，需要进行两次交换，使得每队情侣独立（相互牵手）

3. 如果四对情侣相互坐错了位置，ta们四对之间形成了一个环，需要进行三次交换，使得每队情侣独立（相互牵手）

也就是说，如果我们有 `k` 对情侣形成了错误环，需要交换 `k - 1` 次才能让情侣牵手。

**于是问题转化成 `n / 2` 对情侣中，有多少个这样的环。**

可以直接使用「并查集」来做。

由于 0和1配对、2和3配对 ... 因此互为情侣的两个编号除以 2 对应同一个数字，可直接作为它们的「情侣组」编号：

```Java []
 class Solution {
    int[] p = new int[70];
    void union(int a, int b) {
        p[find(a)] = p[find(b)];
    }
    int find(int x) {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
    public int minSwapsCouples(int[] row) {
        int n = row.length, m = n / 2;
        for (int i = 0; i < m; i++) p[i] = i;
        for (int i = 0; i < n; i += 2) union(row[i] / 2, row[i + 1] / 2);
        int cnt = 0;
        for (int i = 0; i < m; i++) {
            if (i == find(i)) cnt++;
        }
        return m - cnt;
    }
}
```
* 时间复杂度：$O(n)$
* 空间复杂度：$O(n)$

---

## 贪心

![image.png](https://pic.leetcode-cn.com/1613291131-wiYksH-image.png)

还是以「情侣对」为单位进行分析：

由于题目保证有解，我们也可以从前往后（每两格作为一步）处理，对于某一个位置而言，如果下一个位置不是应该出现的情侣的话。

则对下一个位置进行交换。

同时为了方便我们找到某个值的下标，需要先对 `row` 进行预处理（可以使用哈希表或数组）。

```Java []
class Solution {
    public int minSwapsCouples(int[] row) {
        int n = row.length;
        int ans = 0;
        int[] cache = new int[n];
        for (int i = 0; i < n; i++) cache[row[i]] = i;
        for (int i = 0; i < n - 1; i += 2) {
            int a = row[i], b = a ^ 1;
            if (row[i + 1] != b) {
                int src = i + 1, tar = cache[b];
                cache[row[tar]] = src;
                cache[row[src]] = tar;
                swap(row, src, tar);
                ans++;
            }
        }
        return ans;
    }
    void swap(int[] nums, int a, int b) {
        int c = nums[a];
        nums[a] = nums[b];
        nums[b] = c;
    }
}
```
* 时间复杂度：$O(n)$
* 空间复杂度：$O(n)$

---

## 证明/分析

我们这样的做法本质是什么？

**其实相当于，当我处理到第 `k` 个位置的时候，前面的 `k - 1` 个位置的情侣已经牵手成功了。我接下来怎么处理，能够使得总花销最低。**

分两种情况讨论：

a. 现在处理第 `k` 个位置，使其牵手成功：

那么我要使得第 `k` 个位置的情侣也牵手成功，那么必然是保留第 `k` 个位置的情侣中其中一位，再进行修改，这样的成本是最小的（因为只需要交换一次）。

而且由于前面的情侣已经牵手成功了，因此交换的情侣必然在 `k` 位置的后面。

然后我们再考虑交换左边或者右边对最终结果的影响。

分两种情况来讨论：

1. 与第 `k` 个位置的匹配的两个情侣不在同一个位置上：这时候无论交换左边还是右边，后面需要调整的「情侣对数量」都是一样。假设处理第 `k` 个位置前需要调整的数量为 `n` 的话，处理完第 `k` 个位置（交换左边或是右边），需要调整的「情侣对数量」都为 `n - 1` 。
![image.png](https://pic.leetcode-cn.com/1613294210-JIMqBl-image.png)


2. 与第 `k` 个位置的匹配的两个情侣在同一个位置上：这时候无论交换左边还是右边，后面需要调整的「情侣对数量」都是一样。假设处理第 `k` 个位置前需要调整的数量为 `n` 的话，处理完第 `k` 个位置（交换左边或是右边），需要调整的「情侣对数量」都为 `n - 2` 。
![image.png](https://pic.leetcode-cn.com/1613294249-TkefQo-image.png)

因此对于第 `k` 个位置而言，交换左边还是右边，并不会影响后续需要调整的「情侣对数量」。

b. 现在先不处理第 `k` 个位置，等到后面的情侣处理的时候「顺便」处理第 `k` 位置：

由于我们最终都是要所有位置的情侣牵手，而且每一个数值对应的情侣数值是唯一确定的。

因此我们这个等“后面”的位置处理，其实就是等与第 `k` 个位置互为情侣的位置处理（对应上图的就是我们是在等 【0 x】和【8 y】或者【0 8】这些位置被处理）。

由于被处理都是同一批的联通位置，因此和「a. 现在处理第 `k` 个位置」的分析结果是一样的。

---

不失一般性的，我们可以将这个分析推广到第一个位置，其实就已经是符合「当我处理到第 `k` 个位置的时候，前面的 `k - 1` 个位置的情侣已经牵手成功了」的定义了。

**综上所述，我们只需要确保从前往后处理，并且每次处理都保留第 `k` 个位置的其中一位，无论保留的左边还是右边都能得到最优解。**

---

## 最后

**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ ("▔□▔)/**

也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png) 和 加入我们的[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解。

所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~ 