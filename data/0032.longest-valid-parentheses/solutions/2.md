## [32.最长有效括号 中文热门题解2](https://leetcode.cn/problems/longest-valid-parentheses/solutions/100000/shou-hua-tu-jie-zhan-de-xiang-xi-si-lu-by-hyj8)

作者：[xiao_ben_zhu](https://leetcode.cn/u/xiao_ben_zhu)

本文在传达详细思路的前提下尽力保持精简，期待你耐心看完。
#### 起初的思路（行不通）
- 从左往右扫描，已扫描的左括号等待被匹配，用一个栈暂存起来。
- 题目是求长度，存左括号的索引即可，没必要存符号本身。
- 当扫描到右括号，它匹配**最近一个**左括号，栈顶被匹配而出栈，有效长度 = 当前索引-出栈的索引+1，并挑战一下全局的最大
- 如图，当遍历到索引为 6 的右括号时，此时栈中的左括号匹配光了，但左边有一整段长度为 6 的有效子串，**没有被计算**，让索引 6 减 0？不对，索引 0 已经出栈了。或许让 5 减 -1？
![image.png](https://pic.leetcode-cn.com/b2aeae1caba543716209c6d2566a49abcd4d6478f7727627abed718391dbb273-image.png)
#### 修改后的思路
- 在栈中**预置 -1** 作为“参照物”，并改变计算方式：当前索引 - 出栈后新的栈顶索引。
![image.png](https://pic.leetcode-cn.com/5d7c8630b67841475a97775c870fdb63cdfa317ce236a3335667700c5ac5f99f-image.png)
- 当遍历到索引 5 的右括号，此时栈顶为 2，出栈，栈顶变为 **-1**，有效长度为 5 - (-1)。如果照之前那样，5 找不到 -1 减。
- 现在有个问题：当遍历到索引 6 的右括号，它不是需要入栈的左括号，又没有左括号可匹配，怎么处理它？
- 它后面也可能出现这么一段有效长度，它要成为 -1 那样的“参照物”。它之前出现的有效长度都已计算，-1 的使命已经完成了，要被替代。
- 所以我们照常让 -1 出栈。重点是，此时栈空了，让索引 6 入栈取代它。
#### 总结：两种索引会入栈

1. 等待被匹配的左括号索引。
2. 充当「参照物」的右括号索引。因为：当左括号匹配光时，栈需要留一个垫底的参照物，用于计算一段连续的有效长度。
#### 代码
时间复杂度 空间复杂度 都是 $O(n)$
```js 
const longestValidParentheses = (s) => {
  let maxLen = 0;
  const stack = [];
  stack.push(-1);
  for (let i = 0; i < s.length; i++) {
    const c = s[i];
    if (c == '(') {       // 左括号的索引，入栈
      stack.push(i);
    } else {              // 遍历到右括号
      stack.pop();        // 栈顶的左括号被匹配，出栈
      if (stack.length) { // 栈未空
        const curMaxLen = i - stack[stack.length - 1]; // 计算有效连续长度
        maxLen = Math.max(maxLen, curMaxLen);          // 挑战最大值
      } else {            // 栈空了
        stack.push(i);    // 入栈充当参照
      }
    }
  }
  return maxLen;
};
```

### 动态规划
#### 怎么定义`dp[i]`？
- 我们试着拆分子问题，目光盯着子问题与大问题之间的联系
- 感受一下“提供”这词：前一个子问题的解可以“提供”给后一个子问题多大的有效长度。后一个子问题的解，要想纳入前面“提供”的有效长度，则前面子串的末尾必须是有效子串的一部分。（连续性）
- 子问题`dp[i]`：以`s[i]`为结尾的子串中，所形成的最长有效子串的长度，且有效子串是以`s[i]`为结尾。
- 规定有效子串是以`s[i]`为结尾，这样才能“提供”给后一个子问题一段有效长度
#### 紧盯子问题与大问题之间的联结点
关注联结点：子串的末位`s[i]`，它要么是`'('`，要么是`')'`：
1. `s[i]`是`'('`，以它为结尾的子串，肯定不是有效括号子串——`dp[i] = 0`
2. `s[i]`是`')'`，以它为结尾的子串可能是有效子串，还需考察前一个子问题的末尾`s[i-1]`
   1. `s[i-1]`是`'('`，`s[i-1]`和`s[i]`组成一对，有效长度保底为 2，还需考察`s[i-2]`：
      1. `s[i-2]`不存在，则有效长度只有 2——`dp[i] = 2`
      2. `s[i-2]`存在，则加上以`s[i-2]`为结尾的最长有效长度——`dp[i]=dp[i-2]+2`
   2. `s[i-1]`是`')'`，`s[i-1]`和`s[i]`是`'))'`，以`s[i-1]`为结尾的最长有效长度为`dp[i-1]`，跨过这个长度（具体细节不用管，总之它最大能提供`dp[i-1]`长度），来看`s[i-dp[i-1]-1]`这个字符：
      1. `s[i-dp[i-1]-1]`不存在或为`')'`，则`s[i]`找不到匹配，直接gg——`dp[i]=0`
      2.  `s[i-dp[i-1]-1]`是`'('`，与`s[i]`匹配，有效长度 = 2 + 跨过的`dp[i-1]`+ 前方的`dp[i-dp[i-1]-2]`。等一下，`s[i-dp[i-1]-2]`要存在才行！：
          1. `s[i-dp[i-1]-2]`存在，`dp[i] = dp[i-1] + dp[i-dp[i-1]-2] + 2`
          2. `s[i-dp[i-1]-2]`不存在，`dp[i] = dp[i-1] + 2`

- base case ：`dp[0] = 0` 一个括号形成不了有效子串
#### DP 代码
时间复杂度和空间复杂度都是 $O(n)$
```js
const longestValidParentheses = (s) => {
  let maxLen = 0;
  const len = s.length;
  const dp = new Array(len).fill(0);
  for (let i = 1; i < len; i++) {
    if (s[i] == ')') {
      if (s[i - 1] == '(') {
        if (i - 2 >= 0) {
          dp[i] = dp[i - 2] + 2;
        } else {
          dp[i] = 2;
        }
      } else if (s[i - dp[i - 1] - 1] == '(') {
        if (i - dp[i - 1] - 2 >= 0) {
          dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2];
        } else {
          dp[i] = dp[i - 1] + 2;
        }
      }
    }
    maxLen = Math.max(maxLen, dp[i]);
  }
  return maxLen;
};
```

#### 本文经过反复修改，应该是流畅易懂的，文字也是真诚详实的。喜欢的就点个赞鼓励。
最后修改于：2021-07-02