#### 方法一：数学

**提示 $1$**

一个数字进行两次反转操作不变的**充要条件**为：在两次反转操作前后数字的**位数**均不变。

**提示 $1$ 解释**

首先考虑充分性。如果操作前后位数不变，则反转操作等价于数字对应的十进制字符串的反转操作，而字符串反转两次一定等于本身，因此该数字反转两次也为本身。

其次考虑必要性。对于一个数进行反转操作，它的**位数**一定**不会增加**。因此进行两次反转操作后得到的数仍然等于原数，操作过程中必须保证数字位数不变。

**思路与算法**

根据 **提示 $1$** 以及取值范围，我们需要找出两次反转操作前后数字位数均不变的（正）整数。

对于 $0$，进行两次反转操作后仍然为 $0$。

考虑任意**非零**正整数，由于反转操作前后均不保留前导零，因此：

- 对于第一次反转操作，位数不变的充要条件即为该整数**结尾不含 $0$**；

- 对于第二次反转操作，由于第一次操作前的整数不含前导零，因此第二次操作前的整数结尾也不含 $0$，第二次操作前后位数不会改变。

综上，非负整数进行两次反转操作不变的充要条件即为：该整数为 $0$ 或该整数结尾不含 $0$。而后者等价于该数模 $10$ 的余数不为 $0$。我们按照该条件判断并相应返回结果即可。


**代码**

```C++ [sol1-C++]
class Solution {
public:
    bool isSameAfterReversals(int num) {
        return num == 0 || num % 10 != 0;
    }
};
```


```Python [sol1-Python3]
class Solution:
    def isSameAfterReversals(self, num: int) -> bool:
        return num == 0 or num % 10 != 0
```


**复杂度分析**

- 时间复杂度：$O(1)$。

- 空间复杂度：$O(1)$。