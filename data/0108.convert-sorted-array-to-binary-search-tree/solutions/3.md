## [108.将有序数组转换为二叉搜索树 中文热门题解3](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/solutions/100000/yi-wen-du-dong-shi-yao-shi-er-cha-sou-suo-shu-bst-)

作者：[xiao-yan-gou](https://leetcode.cn/u/xiao-yan-gou)

其实这道题解题的本质不在于二叉“搜索”树和中序遍历，本质是“平衡”而已，所以这道题并不难。
&ensp;
（但二叉“搜索”树和中序遍历的概念我们也需要理解，因此我一起讲）
&ensp;
### 由于这道题最重要的是“平衡”，我们首先来看，如何满足平衡条件。
实现二叉树的平衡，其实很简单，就每次把一组数最中间的位置，作为树的头拎起来，剩下部分平均分两份就行，
要是出多来一个数就分配给左脚or右脚
&ensp;
具体实现这个平衡条件，我们可以定义一个函数“做一棵树”，而且这个函数只和数组的长度有关，和具体数字等等通通无关：
&ensp;
```python
def 做一棵树（数组的哪个段落要做成树）：#这个段落用索引表示即可，与具体数字无关
    #假设这个段落叫A吧
    树的根部 = 这个段落A最中间的数字
    树的左边 = 做一棵树（这个段落A的左边部分）
    树的右边 = 做一棵树（这个段落A的右边部分）
    return 这棵树
```
&ensp;
可以看到，如果我们命令："做一棵树(整个数组)"的话，这个嵌套的结构可以让代码循环下去。
即当我们命令“做一棵大树”之后，所有做左右小树的任务，这个嵌套代码都会自动细分下去，自己做好每个节点的构造工作，好有觉悟的代码
&ensp;
竟然就这样完成了平衡工作，其实这个题已经解完了，下面介绍一下什么叫二叉搜索树、中序遍历，你就知道为什么我们已经满足了题目要求的所有条件。
&ensp;
### 什么是二叉搜索树(BST)？ 
&ensp;
其实这个概念也非常简单，二叉树里每个节点都是一个爸爸，每个爸爸有两个儿子
而二叉“搜索”树就是要满足一个额外的条件：所有左儿子的数字都比爸爸数字小，所有右儿子的数字都比爸爸数字大。
示例：
![屏幕快照 2020-07-03 下午12.04.44.png](https://pic.leetcode-cn.com/0219df381cfbd02130b76c0af1d149b6013283d934195c7bc6feab4372b794bd-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-07-03%20%E4%B8%8B%E5%8D%8812.04.44.png)
(图源：力扣（LeetCode）)
我们可以很容易看见，每个爸爸节点分出来的左边部分里，**任何一个**数字都比这个爸爸数字小；右边部分里，**任何一个**数字都比这个爸爸数字大。
&ensp;
至于为什么叫二分“**搜索**”树，我的理解是这样的：
比如我们玩一个游戏，我心里想一个数字，你要猜这个数字是什么，那你可以用这样一棵搜索树，从最顶上的父节点开始，每次问我，“你想的数字比当前节点大还是小？”，你就可以一步步顺着树往下走，搜索到我心里想的数字。所以这就是一个**搜索**的过程，是一个**不断缩小搜索范围**的过程。
&ensp;
言归正传，为什么我们已经满足了题目二分搜索树的条件，因为题目一开始就给了我们一个有序的数列，你每次在中间取一个爸爸，爸爸的左边部分必定小于爸爸数，右边部分也必定大于爸爸树。
&ensp;
### 什么是中序遍历？
官方解答当中，一开始就说，这是一个“中序遍历”。
不了解的同学可能很想问：在哪里遍历？什么中序？马冬什么？
&ensp;
这里说的遍历，实际上是我们**遍历二叉树的方式**。
其实一张图就能给你解释什么叫中序遍历：
（其中，箭头表示遍历顺序。二叉树本身的箭头没画。）
![gaitubao_245597451C41175349BA07FB633B753E (1).jpg](https://pic.leetcode-cn.com/6d8c0e1252e42c034221f90ee6281f0b33a4f228a7f5d2522a585d5b3364de6a-gaitubao_245597451C41175349BA07FB633B753E%20\(1\).jpg)


我们发现，这个“前”、“中”、“后”其实指的就是ROOT在遍历当中的位置嘛，左右两部分则一直都是从左到右。
&ensp;
比如**中序**遍历的过程，我们来看一个例子：
如下一棵随便画的二叉树，搞得很丑但我不管：
![gaitubao_05F224100CE80C6A640F305AA762A886 (1).jpg](https://pic.leetcode-cn.com/7b5367bf0110e9c7d91c10b400f3fbf34376e04bdf326b4a526b4b329e5043f9-gaitubao_05F224100CE80C6A640F305AA762A886%20\(1\).jpg)



注意，遍历的时候，记住一个关键点：**我们遍历的是树而不是节点**
这么说有点抽象，具体一点说：每次遍历的时候，要把子树看成一个整体，
比如我们来看一个最大的格局：爸爸节点是1号，那么左子树是2、4、5、7、8整个整体，右子树是3、6、9、10整个整体，
在这个最大格局上进行遍历，那就是左子树整体->1号->右子树整体
&ensp;
所以我们现在知道要从左子树开始，那么左子树也要遵循中序遍历，所以顺序应该是
4、7整体 -> 2 -> 5、8整体
&ensp;
然后进入1
&ensp;
然后进入右子树，右子树也遵循中序遍历：
空白(3开头的右子树并没有左边部分) -> 3 -> 6、9、10整体
&ensp;
依此类推，如果你能理解完整的顺序：
4、7、2、8、5、1、3、9、6、10
说明你已经理解了中序遍历，记住每次进入一个子树的时候，不要急着先遍历这个子树的爸爸，每个子树也都是要从左边开始才能是中序遍历的！

#### 那么，为什么我们的题目是中序遍历？
看一下我们为例题创建的树吧：
![屏幕快照 2020-07-03 下午1.01.41.png](https://pic.leetcode-cn.com/e460804580a773d5c5aab3aea26c16f5ef9f28870bf023bdc6338b130e3ff236-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-07-03%20%E4%B8%8B%E5%8D%881.01.41.png)
(图源：力扣（LeetCode）)
如果你用中序遍历的方式遍历它，输出的数字是怎样的：-10、-3、0、5、9
&ensp;
哟呵，这不就是题目给出的那个数组吗[-10、-3、0、5、9], 所以“这道题是中序遍历”的意思，其实就是说，这个给出的数组，是在以中序遍历的方式遍历我们创建的树。
&ensp;
嗯，所以这个其实和能不能解出这道题好像关系没有很大啦。
&ensp;
### Python代码讲解注释

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:

        def make_tree(start_index, end_index): #只和长度有关
            #首先判定我们的区间是否合理，即left_index要<=right_index
            #当相等时，只有root会产生，不会产生左右小树
            if start_index > end_index:
                return None
            
            #我这里变量名都写得比较长，目的是方便理解
            mid_index = (start_index + end_index)//2
            this_tree_root = TreeNode(nums[mid_index]) #做一个小树的root

            this_tree_root.left = make_tree(start_index,mid_index-1)
            this_tree_root.right = make_tree(mid_index+1, end_index)

            return this_tree_root #做好的小树
        
        return make_tree(0,len(nums)-1) 
        #可以看到整个题解只和index有关，和数组里的具体数字无关，
        #因为题目给出的“有序数列”帮助我们满足了“二叉搜索树”的条件。
```

