## [1713.得到子序列的最少操作次数 中文热门题解1](https://leetcode.cn/problems/minimum-operations-to-make-a-subsequence/solutions/100000/gong-shui-san-xie-noxiang-xin-ke-xue-xi-oj7yu)

作者：[AC_OIer](https://leetcode.cn/u/AC_OIer)
## 基本分析

为了方便，我们令 $target$ 长度为 $n$，$arr$ 长度为 $m$，$target$ 和 $arr$ 的最长公共子序列长度为 $max$，不难发现最终答案为 $n - max$。

因此从题面来说，这是一道最长公共子序列问题（LCS）。

但朴素求解 LCS 问题复杂度为 $O(n * m)$，使用状态定义「**$f[i][j]$ 为考虑 `a` 数组的前 $i$ 个元素和 `b` 数组的前 $j$ 个元素的最长公共子序列长度为多少**」进行求解。

而本题的数据范围为 $10^5$，使用朴素求解 LCS 的做法必然超时。

一个很显眼的切入点是 $target$ 数组元素各不相同，当 LCS 问题增加某些条件限制之后，会存在一些很有趣的性质。

其中一个经典的性质就是：**当其中一个数组元素各不相同时，最长公共子序列问题（LCS）可以转换为最长上升子序列问题（LIS）进行求解。同时最长上升子序列问题（LIS）存在使用「维护单调序列 + 二分」的贪心解法，复杂度为 $O(n\log{n})$。**

**因此本题可以通过「抽象成 LCS 问题」->「利用 $target$ 数组元素各不相同，转换为 LIS 问题」->「使用 LIS 的贪心解法」，做到 $O(n\log{n})$ 的复杂度。**

基本方向确定后，我们证明一下第 $2$ 步和第 $3$ 步的合理性与正确性。

---

## 证明

#### 1. 为何其中一个数组元素各不相同，LCS 问题可以转换为 LIS 问题？

**本质是利用「当其中一个数组元素各不相同时，这时候每一个“公共子序列”都对应一个不重复元素数组的下标数组“上升子序列”，反之亦然」。**

我们可以使用题目给定的两个数组（$target$ 和 $arr$）理解上面的话。

由于 $target$ 元素各不相同，那么首先 $target$ 元素和其对应下标，具有唯一的映射关系。

然后我们可以**将重点放在两者的公共元素上（忽略非公共元素），每一个“公共子序列”自然对应了一个下标数组“上升子序列”，反之亦然**。

注意：下图只画出了两个数组的某个片段，不要错误理解为两数组等长。

![image.png](https://pic.leetcode-cn.com/1627265496-KtDwZl-image.png)

如果存在某个“公共子序列”，根据“子序列”的定义，那么对应下标序列必然递增，也就是对应了一个“上升子序列”。

反过来，对于下标数组的某个“上升子序列”，首先意味着元素在 $target$ 出现过，并且出现顺序递增，符合“公共子序列”定义，即对应了一个“公共子序列”。

至此，我们将原问题 LCS 转换为了 LIS 问题。

#### 2. 贪心求解 LIS 问题的正确性证明？

朴素的 LIS 问题求解，我们需要定义一个 $f[i]$ 数组代表以 $nums[i]$ 为结尾的最长上升子序列的长度为多少。

对于某个 $f[i]$ 而言，我们需要往回检查 $[0, i - 1]$ 区间内，所有可以将 $nums[i]$ 接到后面的位置 $j$，在所有的 $f[j] + 1$ 中取最大值更新 $f[i]$。因此朴素的 LIS 问题复杂度是 $O(n^2)$ 的。

**LIS 的贪心解法则是维护一个额外 $g$ 数组，$g[len] = x$ 代表上升子序列长度为 $len$ 的上升子序列的「最小结尾元素」为 $x$。**

整理一下，我们总共有两个数组：
* $f$ 动规数组：与朴素 LIS 解法的动规数组含义一致。$f[i]$ 代表以 $nums[i]$ 为结尾的上升子序列的最大长度；
* $g$ 贪心数组：$g[len] = x$ 代表上升子序列长度为 $len$ 的上升子序列的「最小结尾元素」为 $x$。

由于我们计算 $f[i]$ 时，需要找到满足 $nums[j] < nums[i]$，同时取得最大 $f[j]$ 的位置 $j$。

我们期望通过 $g$ 数组代替线性遍历。

显然，如果 $g$ 数组具有「单调递增」特性的话，我们可以通过「二分」找到符合 $g[idx] < nums[i]$ 分割点 $idx$（下标最大），即利用 $O(\log{n})$ 复杂度找到最佳转移位置。

我们可以很容易 **通过反证法结合 $g$ 数组的定义来证明 $g$ 数组具有「单调递增」特性。**

假设存在某个位置 $i$ 和 $j$，且 $i < j$，不满足「单调递增」，即如下两种可能：

* $g[i] = g[j] = x$：这意味着某个值 $x$ 既能作为长度 $i$ 的上升子序列的最后一位，也能作为长度为 $j$ 的上升子序列的最后一位。
    根据我们对 $g$ 数组的定义，$g[i] = x$ 意味在所有长度为 $i$ 上升子序列中「最小结尾元素」为 $x$，但同时由于 $g[j] = x$，而且「上升子序列」必然是「严格单调」，因此我们可以通过删除长度为 $j$ 的子序列后面的元素（调整出一个长度为 $i$ 的子序列）来找到一个比 $g[i]$ 小的合法值。
    也就是我们找到了一个长度为 $i$ 的上升子序列，且最后一位元素必然严格小于 $x$。因此 $g[i] = g[j] = x$ 恒不成立；

* $g[i] > g[j] = x$：同理，如果存在一个长度为 $j$ 的合法上升子序列的「最小结尾元素」为 $x$ 的话，那么必然能够找到一个比 $x$ 小的值来更新 $g[i]$。即 $g[i] > g[j]$ 恒不成立。

根据全序关系，在证明 $g[i] = g[j]$ 和 $g[i] > g[j]$ 恒不成立后，可得 $g[i] < g[j]$ 恒成立。

至此，我们证明了 $g$ 数组具有单调性，从而证明了每一个 $f[i]$ 均与朴素 LIS 解法得到的值相同，即贪心解是正确的。

---

## 动态规划 + 贪心 + 二分

根据「基本分析 & 证明」，通过维护一个贪心数组 $g$，来更新动规数组 $f$，在求得「最长上升子序列」长度之后，利用「“公共子序列”和“上升子序列”」的一一对应关系，可以得出“最长公共子序列”长度，从而求解出答案。

代码：
```Java []
class Solution {
    public int minOperations(int[] target, int[] arr) {
        int n = target.length, m = arr.length;
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < n; i++) map.put(target[i], i);
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < m; i++) {
            if (map.containsKey(arr[i])) list.add(map.get(arr[i]));
        }
        int len = list.size(), max = 0;
        int[] f = new int[len + 1], g = new int[len + 1];
        Arrays.fill(g, Integer.MAX_VALUE);
        for (int i = 0; i < len; i++) {
            int t = list.get(i);
            int l = 0, r = len;
            while (l < r) {
                int mid = l + r + 1 >> 1;
                if (g[mid] < t) l = mid;
                else r = mid - 1;
            }
            int clen = r + 1;
            f[i] = clen;
            g[clen] = Math.min(g[clen], t);
            max = Math.max(max, f[i]);
        }
        return n - max;
    }
}
```
* 时间复杂度：通过 $O(n)$ 复杂度得到 $target$ 的下标映射关系；通过 $O(m)$ 复杂度得到映射数组 $list$；贪心求解 LIS 的复杂度为 $O(m\log{m})$。整体复杂度为 $O(n + m\log{m})$
* 空间复杂度：$O(n + m)$

---

## 最后

**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ ("▔□▔)/**

也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png) 和 加入我们的[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解。

所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~ 