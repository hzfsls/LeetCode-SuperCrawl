## [1449.数位成本和为目标值的最大数字 中文热门题解2](https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target/solutions/100000/xiang-xi-jiang-jie-wan-quan-bei-bao-zhuang-tai-de-)

作者：[ofshare](https://leetcode.cn/u/ofshare)

首先我翻看了一眼题解区, 发现大家讲的都很简略, 甚至连基本的, 状态的转移都没有说清楚, 忍不住吐槽一句(~~现在lc的题解都是这样的嘛, 贴个代码随便写点东西, 就可以发在题解区了, 没有任何审核de嘛?~~)

**回到正文**, 一般看到(恰好)构成target的字样, 大多与背包有关. 本题就是每个数字可以无限选, 每个数字有一个cost, 问选择的数字cost加起来恰好等于target时, 数字的最大值.

因为每个数字可以无限选, 所以是一道`完全背包`. 

根据题目, 我们可以这样定义状态, dp[i][j]表示`前i个元素, 恰好构成成本为j时, 构成的最大的整数(整数用字符串表示, 无效状态用'#'表示)`. (注意背包问题里, 我都是以下标1开始的)

状态有了, 我们接着考虑如何转移, 如果`你是第一次接触完全背包, 那么一种自然的转移就是枚举第i个元素, 选了多少了`, 这种方式是对的, 但是对于这个问题, 却有着更加`经典且时间复杂度更优的做法`我这里自认为详细的解释一下.

因为第i件物品(即本题的第i个元素, 后面不加区分)可以无限选, 所有我们可以`分为第i件物品选0个, 和至少选1个, 这两大类`. 在考虑第i件物品转移的时候, 我们肯定也要把它选的所有的情况都考虑完才对, 下面给出`转移方程`:

`dp[i][j] = std::max(dp[i - 1][j], dp[i][j - cost[i]] + value[i])` 

`dp[i - 1][j]`: `表示第i件物品选0个`

`dp[i][j - cost[i]] + value[i]`: `表示第i件物品至少选一个`

这样我们就把第i件物品可以`选无限个`都考虑到了. 是不是很巧妙?

我在第一次看到这个方程时, 也疑惑了半天, 也惊叹这方程的美. 我这里再解释下

我们回到`dp[i][j - cost[i]]`这个状态代表了什么去思考, 它表示前i个物品, 恰好装进容量为j - cost[i]时能获得的最大值, 里面是不是就包含了此时的背包里装了0个, 或者1个, 或者2个, 或者3个... 第i件物品, 方程后面 `+value[i]表示把第i件物品放一个进去`, 那么此时背包里, 是不是就包含1个, 或者2个, 或者3个, ... `即至少装了1个第i件物品`. 这也是背包九讲里说的`加选一件`的概念. 这是理解完全背包的关键, 希望大家好好理解(也希望我讲清楚了哈哈哈哈lol)．

这样我们就把第i件物品选无限个, 不重不漏的都考虑到了.

到这里, 状态的定义, 以及状态的转移都有了, 基本差不多了, 就只剩下状态的初始情况. 

对于`初始状态dp[0][j]`, 因为前面0个物品(即没有物品), 那么可以按恰好装满还是不装满划分, 比如说dp[0][5], 前面没有物品, 你却要我装满背包容量为5的体积, 这种状态显然是非法的, 根据题目要求我们可以设置相应的非法状态即可. 因为dp[0][j]这个状态可以很好的表示初始时候的状态, 所以背包问题里, 我都是`按下标为1开始的`.

到这里差不多本题就讲的差不多了, 后面还剩下一点细枝末节. 因为本题后面的数字比前面的大, 所以是加在`原来的最大的数字的前面以此来构造更大的数字`, 对于非法状态用"#"表示, 初始化时只有dp[0][0]是合法的, 其他的dp[0][j]都是非法的, 本题求的是字符串的最大值, 所以不是直接std::max(), 而是自己写了一个string_max函数返回较大的那个字符串.

下面是参考代码:

 ```
class Solution {
public:
    int cost[9 + 5];
    string dp[9 + 5][5000 + 5];
    // 返回两者较大的一个
    string string_max(const string &lhs, const string &rhs) {
        if (lhs.size() > rhs.size()) return lhs;
        if (rhs.size() > lhs.size()) return rhs;
        // 当两字符串长度相等时
        if (lhs > rhs) return lhs;
        else return rhs;
    }
    string largestNumber(vector<int>& c, int target) {
        int len = c.size();
        for (int i = 0; i < len; ++i) {
            cost[i + 1] = c[i];
        }
        // dp[i][j]表示前i个元素, 恰好构成成本为j时, 构成的最大的整数(整数用字符串表示)
        // 无效状态用'#'表示
        for (int j = 0; j <= target; ++j) {
            dp[0][j] = '#';
        }
        dp[0][0] = "";
        for (int i = 1; i <= 9; ++i) {
            for (int j = 0; j <= target; ++j) {
                string a, b;
                // 不选第i个
                a = dp[i - 1][j];
                // 加选一个
                if (j - cost[i] >= 0 && dp[i][j - cost[i]] != "#")
                    b = std::to_string(i) + dp[i][j - cost[i]];
                dp[i][j] = string_max(a, b);
            }
        }
        if (dp[9][target] == "#") return "0";
        else return dp[9][target];
    }
};
```

---

- 最后说一点题外话, 绝大部分的编程高手都不会怎么详细写题解, 因为写出一篇详细的题解所需要耗的时间通常是解出一道题的4, 5倍或许还要多的时间, 所以绝大部分他们都不愿意花费这些时间(~~有这时间还不如多刷几道题呢~~), 所以如果大家看到好的题解尽量点赞捧场, 算是给予写详细题解人的激励吧, 或许这样更多的编程高手愿意分享他们的解法, 思路, 心得等. (ps本人并不是什么编程高手, 纯属有感而发)

- 最后, 不要脸的打个自己github上的广告, 欢迎star, 感谢捧场哈哈哈哈lol.
[Algorithm-challenger](https://github.com/OFShare/Algorithm-challenger)
[dp专题系统学习](https://github.com/OFShare/Algorithm-challenger/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/README.md), 难度基本从易到难再到易, 里面dp题的难度可能并非严格从易到难的, 后续可能会按难度重新排序一下, 或者按照各类dp, 如区间dp, 数位dp这些分一下类, 但是看的人以及反馈的人实属太少了, 没有什么更新的动力, 所以一直被搁浅了. 但我一直是想做好这件事的哈哈哈lol
---

**欢迎下方评论区交流讨论～**