## [1359.有效的快递序列数目 中文热门题解1](https://leetcode.cn/problems/count-all-valid-pickup-and-delivery-options/solutions/100000/zu-he-shu-xue-ti-by-paulzfm)

作者：[paulzfm](https://leetcode.cn/u/paulzfm)
## Motivation

注意到题设中的约束只有：对于第 `i` 个订单，其配送总是在其收件服务之后，即 `Pi` 先于 `Di`。而订单之间没有任何约束。由此，可以尝试能否从某个 $n-1$ 的解（序列长度 $2(n-1)$）出发，扩展出来 $n$ 的解（序列长度$2n$）。

考虑某个 2 的解 `(P1,P2,D1,D2)`。不难发现，将 `P3` 和 `D3` 插入到此序列中无非以下两种方法：

- 插入的时候二者连续出现。根据约束，只能先 `P3` 后 `D3`，可插入的空位有 $C_5^1 = 5$ 个；
- 插入的时候二者隔开出现。根据约束，`D3` 插入的空位只能在 `P3` 后，把这两个空位开成一组，共有 $C_5^2 = 10$ 组。

因此，从 `(P1,P2,D1,D2)` 出发扩展出来的 3 的解共有 ($5 + 10 = 15$) 个。而每一个 2 的解都如上述方法能扩展出来 15 个 3 的解，且不难看出这些解之间没有任何重复，那么 3 的解就是 $6 \times 15 = 90$。

## Solution

上述方法一般化如下：

设 $P(n)$ 为 $n$ 笔订单的有效的快递序列数目，则

$$P(n) = P(n - 1) \times (C_{2(n-1)+1}^2 + C_{2(n-1)+1}^1)$$

初始条件为 $P(1) = 1$。

由于任何一轮的迭代过程仅依赖于上一轮的结果，我们只需要常数的空间和线性的时间即可求解，如下 C++ 代码所示：

```c++
const int MOD = 1000000007;

int countOrders(int N) {
    long long P = 1;
    for (int n = 2; n <= N; n++) {
        long long a = 2 * (n - 1) + 1;
        long long b = a * (a - 1) / 2 + a;
        P = (b * P) % MOD;
    }

    return P;
}
```
