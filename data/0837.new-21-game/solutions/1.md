## [837.新 21 点 中文热门题解1](https://leetcode.cn/problems/new-21-game/solutions/100000/huan-you-bi-zhe-geng-jian-dan-de-ti-jie-ma-tian-ge)

作者：[Mcdull0921](https://leetcode.cn/u/Mcdull0921)

#### 解题思路
老实说，一开始没懂题目意思，后面才知道是求爱丽丝的胜率。
规则是这样：
1. 她可以从牌面为 `[1,W]` 的牌中选择任意一张，这张牌是可以无限重复的，也就是说无论她取多少次，每次取到 2（假如 2 在 `[1,W]` 范围内）的概率都是 `1/W`;
2. 如果她手上牌的总额小于 `K`，她就会抽牌，大于等于 `K` 时，就停止抽牌;
3. 停止抽牌后，她的牌面小于等于 `N` 时，她就获胜了，求她获胜的概率。

假设 `dp[x]` 为她手上牌面为x时，能获胜的概率，那么这个概率应该是：
`dp[x]=1/w * (dp[x+1]+dp[x+2]+dp[x+3]...+dp[x+w])`
因为抽取的牌面机会都是均等的，她能抽取的面值在 `[1,W]` 之间，所以将概率之和平均一下就是 `dp[x]` 的概率。
> 强插一段解释：
> `x`代表爱丽丝手上的牌面值，`dp[x]`代表爱丽丝手上持有的牌面值为`x`时，她获胜的概率（游戏结束时她所持牌面值小于等于N的概率）。
> 这个概率是怎么来的？x分2种情况:
> 1. 当x>=K时，爱丽丝会停止抽牌，这个时候游戏已经结束了，她是赢是输也已经确定了，所以此时赢的概率要么1，要么0
> 2. 当x<K时，爱丽丝会继续抽牌，抽牌是有概率的，所以她是赢是输也有概率。
> 她能抽到的牌面值在 `[1,W]` 之间，所以抽完后她的牌面在`[x+1,x+w]`之间，因为每张牌机率均等，所以抽完后牌面在`[x+1,x+w]`之间的每个面值概率都是相等的，而假如我们已知当牌面是`[x+1,x+w]`的胜率(即`dp[x+1]...dp[x+w]`的值)，那么可以推导：
> `dp[x]=1/w * dp[x+1]+ 1/w * dp[x+2] + 1/w * dp[x+3]...+ 1/w * dp[x+w]`
> 这个实际上就是动态规划的状态转移方程，不过本例是反着来转移的。

`x` 最多能到 `K-1`，因为当大于等于 `K` 时，爱丽丝会停止抽牌，所以当游戏结束时，即爱丽丝停止抽牌时，她可能达到的最大牌面是 `K+W-1`，而一开始她的牌面是 `0`，所以我们用一个长度为 `K+W` 的 `dp` 数组来保存她在所有面值下的胜率。
最后 `dp[0]`，也就是最开始爱丽丝还没有抽牌，她的牌面为 `0` 时的胜率，这个就是我们的答案。

#### 填格子游戏开始

![image.png](https://pic.leetcode-cn.com/c8ea4dd9a6e8a03323674d1da11fa6f940535b1c700ee9e3d013ea54b30cab8a-image.png)

我将这个格子分成了 2 部分 `[0,K-1]` 和 `[K,K+W-1]`，区别就是 `[0,K-1]` 爱丽丝可以抽牌，`[K,K+W-1]` 时不能抽牌，那么不能抽牌时她获胜的概率是多少呢，此时已不能抽牌，要么赢要么输，很显然牌面小于等于N时，概率就是 1，大于 `N` 概率就是 0，所以先直接填满图中蓝色的格子。

接下来，从 `K-1` 开始填图中的橘色部分，这个值根据我们前面提到的计算方式，实际上就相当于它后面 `W` 个格子的总和除以 `W`，
这时聪明的你一定会想到不用每轮都累加的方法吧，用一个 `s` 变量来保存累加结果，而下一轮只是减去右边的格子，加上左边的格子即可。

![image.png](https://pic.leetcode-cn.com/e8a044339602f6f2e86ddefa320f7d4d90ad626d9af5c76da926cb0c9356b555-image.png)

所以这题你要做的就是，先初始化蓝色格子，然后从最右边的橘色格子开始，填到最左边的格子，就是这么简单，不仅简单，而且你连动态规划的思想都学会了。
相信这么厉害的你，看到这里给我点个赞一定不是件很困难的事吧。

#### 代码

```Python3 []
class Solution:
    def new21Game(self, N: int, K: int, W: int) -> float:
        dp=[None]*(K+W)
        s=0
        for i in range(K,K+W):          # 填蓝色的格子
            dp[i] = 1 if i<=N else 0
            s+=dp[i]
        for i in range(K-1,-1,-1):      # 填橘黄色格子
            dp[i]=s/W
            s=s-dp[i+W]+dp[i]
        return dp[0]
```

时间复杂度=格子长度 $O(K+W)$
空间复杂度=格子长度 $O(K+W)$