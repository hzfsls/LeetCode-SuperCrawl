## [924.尽量减少恶意软件的传播 中文热门题解1](https://leetcode.cn/problems/minimize-malware-spread/solutions/100000/bing-cha-ji-by-yexiso-mnog)

作者：[yexiso](https://leetcode.cn/u/yexiso)
# 题意分析

- 有一张无向图`graph`，共 `n` 个节点，由若干个子连通图组成。
- 某些节点`initial`在初始时被感染，且会在其所处的连通图中进行传播，不与感染节点连接的节点不会受到感染。
- 在该连通图中，我们可以任意删除一个被感染的节点，将其置为【未被感染】的状态，其他条件不变


> 问：在允许恢复一个被感染节点的条件下，恢复哪个节点，能使得被感染节点数量最小化


# 思路一：重构并查集 （n次）

### 1）分析

题目意思很明确，只要一个连通子图中存在一个节点被感染，那么整个子图都将被感染。

那么思路就比较简单了，我们依次遍历initial中的被感染节点i，判断节点i被恢复之后，图graph有多少个节点依然被感染，我们只需要找到这个能使被感染节点数最少、下标最小的i即可。


### 2）步骤
> 1. 遍历`initial`中的`节点 i`， 将 `节点 i ` 恢复成【未被感染的状态】
> 2. 根据图`graph`构建并查集，并记录有多少个连通分量，每个连通分量有多少个节点被感染 `Infecti`
> 3. 根据第2步的结果，计算整个图有多少节点被感染，记作 `M`
> 4. 重复步骤 1 - 3， 找出能使被感染节点数最小的节点 `i`


### 3）代码

```
class DJset {
public:     
    vector<int> parent;
    vector<int> rank;
    vector<int> size;

    DJset(int n): parent(n), rank(n), size(n, 1) {
        for (int i = 0; i < n; i++) {
            parent[i] = i;   
        }
    }

    int find(int x) {
        if (x != parent[x]) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    void merge(int x, int y) {
        int rx = find(x);
        int ry = find(y);
        if (rx != ry) {
            if (rank[rx] < rank[ry]) swap(rx, ry);
            parent[ry] = rx;
            size[rx] += size[ry];
            size[ry] = 0;
            if (rank[rx] == rank[ry]) rank[rx] += 1;
        }
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        sort(initial.begin(), initial.end());
        int minM = n;         // 记录最少感染节点数
        int idx = initial[0]; // 记录产生最少感染节点数的 删除节点

        // 计算在删除 e 节点的条件下，有多少个节点被感染
        for (auto& e : initial) {
            int M = 0;
            DJset ds(n);
            // 重构并查集
            for (int i = 0; i < n; i++) {
                for (int j = i + 1; j < n; j++) {
                    if (graph[i][j] == 1) ds.merge(i, j);
                }
            }
            // 计算重构之后的感染节点数
            unordered_set<int> seen;
            for (auto& i : initial) {
                if (i == e) continue;
                int ri = ds.find(i);
                if (seen.count(ri)) continue;
                seen.insert(ri);
                M += ds.size[ri];
            }
            if (M < minM) {
                minM = M;
                idx = e;
            }
        }

        return idx;
    }
};
```

# 思路二、构造1次 + 分析

### 1） 分析

思路一需要针对initial中每个被感染的节点重构并查集，这样带来了很大的时间消耗。

> 我们再仔细分析一下题意，能否只在最开始的时候，只构造1次并查集。

好的，我们先看看连通子图中的**被感染节点个数**与最后子图的**状态**之间的关系

|被感染节点数|说明|
|:-:|:-:|
|小于 1|连通子图的节点均正常，不存在需要恢复的节点|
|等于 1|只需要恢复该被感染节点，整个连通子图将恢复正常|
|大于 1|就算恢复该被感染节点，整个连通子图也无法恢复正常|


所以基于此，分以下情况讨论：

> - 如果连通子图中的感染节点数 为 0， 也就是说没有节点被感染，不需要删除节点。**所以，最后删除的节点一定不在该连通子图**
> - 如果连通子图中的感染节点数 为 1， 说明该连通图中只有 1 个节点被感染。**只需要删除该节点， 整个连通子图中的节点将不会被感染**。
> - 如果连通子图中的感染节点数 大于 1，说明该连通子图中有多个节点被感染，而**就算我们删除了一个节点，该连通子图中的节点也依然会被感染**，所以最后删除的节点也大概率不在该连通子图，除非所有连通子图的感染节点数都大于 1；


### 2）例子

<![1.jpg](https://pic.leetcode-cn.com/1612107342-qGvzWf-1.jpg),![2.jpg](https://pic.leetcode-cn.com/1612107358-GsJJEu-2.jpg),![3.jpg](https://pic.leetcode-cn.com/1612107364-PMaimL-3.jpg),![4.jpg](https://pic.leetcode-cn.com/1612107371-damXZd-4.jpg)>


### 3）代码

```cpp
class DJset {
public:     
    vector<int> parent;
    vector<int> rank;
    vector<int> size;

    DJset(int n): parent(n), rank(n), size(n, 1) {
        for (int i = 0; i < n; i++) {
            parent[i] = i;   
        }
    }

    int find(int x) {
        if (x != parent[x]) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    void merge(int x, int y) {
        int rx = find(x);
        int ry = find(y);
        if (rx != ry) {
            if (rank[rx] < rank[ry]) swap(rx, ry);
            parent[ry] = rx;
            size[rx] += size[ry];
            size[ry] = 0;
            if (rank[rx] == rank[ry]) rank[rx] += 1;
        }
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        sort(initial.begin(), initial.end());

        // 合并 连通点
        DJset ds(n);
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j] == 1) ds.merge(i, j);
            }
        }

        // 计算每个连通分量的感染个数
        vector<int> infect(n);
        for (auto& i : initial) {
            infect[ds.find(i)]++;
        }

        int maxM = INT_MIN;
        int idx = initial[0];
        for (auto& i : initial) {
            int ri = ds.find(i);
            // 连通分量的感染节点如果多于 1， 最后该连通分量肯定会全部感染
            if (infect[ri] != 1) continue;
            // 连通分量的感染节点为 1， 去掉该节点后，最后该连通分量全部正常
            if (ds.size[ri] > maxM) {
                maxM = ds.size[ri];
                idx = i;
            }
        }

        return idx;
    }
};
```


# 总结

很明显，思路二的耗时要比思路一少很多。

> 主要是由于本题中对 被感染节点的恢复不会影响其与其他节点之间的连接关系，所以其所处连通子图的内部连接关系不会产生变化。

但是，如果被感染节点的删除影响了其与其他节点的连接关系，那思路二将不再适用，如[928. 尽量减少恶意软件的传播 II](https://leetcode-cn.com/problems/minimize-malware-spread-ii/)