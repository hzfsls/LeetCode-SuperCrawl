## [2289.使数组按非递减顺序排列 中文热门题解2](https://leetcode.cn/problems/steps-to-make-array-non-decreasing/solutions/100000/by-newhar-6k75)

作者：[newhar](https://leetcode.cn/u/newhar)
题外话：比赛时难免会有卡住，感觉推不出更优的结论，这时直接用模拟的办法 + 优化也可以一试的~ 这里提供一个模拟 + 优化的解。

---

**UPDATE: 最优解是单调栈，下面讲解切入点和思考思路**
1. 对于每个 $nums[i]$，如果它被消除，其要么是被 **左侧第一个更大的元素 $nums[j]$** 消除的，要么是下面的情况。
   > 这种情况是当 $nums[j]$ 消除 $nums[i]$ 之前，$nums[j]$ 自身已经被 $nums[k] (k < j)$ 消除。但是这种情况下，**相当于$nums[k]$ 代替了 $nums[j]$ 的位置**，无论这种替换发生了多少次，都不会影响最终答案。因此 **仍然只需考虑左侧第一大元素 $nums[j]$** 即可。

   我们可以用 **单调栈** 求左侧第一个更大元素。（如果找不到左侧第一个更大元素，那么它永远不会被消除）
2. 设 $nums[i]$ 被 $nums[j](j < i)$ 消除。那么，位于 $j$ 和 $i$ 之间的元素一定被首先消除，使得 $nums[j]$ 和 $nums[i]$ 相邻，然后再是 $nums[j]$ 消除 $nums[i]$。设 $f[i]$ 为 $nums[i]$ 被消除所需的轮数，那么 $f[i] = \displaystyle{\max(f[j+1]\dots f[i-1]) + 1}$。
3. $\max(f[j+1]\dots f[i-1])$ 可以在更新单调栈时同时统计。
   > 我们只需要统计 $[i+1,j-1]$ 中 **仍然在单调栈里的元素** 的步数中的最大值即可。因为那些不在单调栈里的元素，当它们被 pop 之后，一定会 push 进一个比他们的最大值 $max$ 还大 $1$ 的元素，因此这个被 push 进的元素可以 “代表” 所有被 pop 的元素。
4. 最终的答案就是 $\max(f[i])$。

```c++
class Solution {
public:
    int totalSteps(vector<int>& nums) {
        // 单调栈
        // 1. 每个元素一定时被左侧第一个更大的元素消除的
        // 2. 设 x 消除 y，也就是 [x] .... [y]，那么
        //    中间的 .... 一定先被消除，再 +1 次消除（x 消除 y）
        // 3. 那么，x 被消除所需轮数就是 [....] 中的最大消除轮数 + 1
        int res = 0, f[nums.size()];
        stack<int> st;
        for(int i = 0; i < nums.size(); ++i) {
            int cur = 0;
            while(st.size() && nums[st.top()] <= nums[i]) {
                cur = max(cur, f[st.top()]);
                st.pop();
            }
            if(st.size()) {
                res = max(res, cur + 1);
                f[i] = cur + 1;
            }
            st.push(i);
        }
        return res;
    }
};
```

---

**以下是比赛时的解法（单链表模拟 + 优化）：**

再读理顺一遍题意：每次操作，**从后向前遍历 $nums$ 数组**， 如果 $nums[i]$ 比后面的数字大，那么 $nums[i]$ 可以 “吃掉” 后面的数字。重复操作直到整个数组不在有数字被吃。

为什么要 从后向前 遍历，因为被吃掉的数字本身也可能吃掉其它数字，比如 $[11,8,5,11]$，首先 $8$ 可以吃掉 $5$，然后 $11$ 可以吃掉 $8$，那么从后往前遍历可以保证一次操作把 $8$ 和 $5$ 全部吃掉。

---

直接模拟，遍历 $n$ 次数组一定会超时。但是我们有一个重要的结论：**如果在某次操作后，$nums[i] \le nums[i+1]$，那么 $nums[i]$ 就再也不能继续 “吃掉” 后面的数字了**。根据这个结论，我们可以采用以下的单链表模拟的思路：

首先把数组转换为单链表。一开始，我们统计一个列表 $v$，表示所有可以向后吞噬的数字的下标。

每一轮操作中，我们按 **下标 $i$ 递减的顺序** 遍历列表 $v$，对于其中的每个下标 $i$，

- 如果 $nums[i]$ 没有被吃掉，且 $nums[i] >$ 它的 **后继元素**，那么 **删除** $nums[i]$ 的 后继元素。另外，$nums[i]$ 在下一轮的操作中可能继续吃掉其它数字，将其保存到一个新的列表 $v2$ 中，。

- 否则，要么 $nums[i]$ 被吃掉，要么 $nums[i] \le$ 它的后继元素。在这两种情况下，$nums[i]$ 都再也不能吃掉掉后面的数字了，因此直接丢弃即可。

操作结束后：

- 如果 $v2$ 为空，那么表示本轮实际上并没有进行任何操作，返回已经进行的操作数；
- 如果 $v2$ 不为空，那么表示本轮进行了吞噬操作，那么操作数 $+1$，并将 $v2 \rightarrow v$，重新执行下一轮操作。

---

**时间复杂度分析**

在每轮操作中，对于每个在列表 $v$ 中的下标 $i$，有 $2$ 种命运：

- $nums[i]$ 吞噬掉了其后继元素，并被保存到新列表 $v2$ 中，以供后续操作；
- $nums[i]$ 被丢弃。

因此，对于每个下标 $i$，其操作的次数 = 它吞噬掉的元素数 $+1$。而总共被吞噬掉的元素数不超过 $n$，因此时间复杂度为 $O(n)$。

```c++
class Solution {
public:
    int totalSteps(vector<int>& nums) {
        // 尾部加入一个很大的数方便后续编码
        nums.push_back(1e9 + 8);
        int n = nums.size(), ne[n], rem[n];
        for(int i = 0; i < n; ++i) ne[i] = i+1, rem[i] = 1;
        
        vector<int> v;
        for(int i = n-2; i >= 0; --i) {
            if(nums[i] > nums[i+1]) v.push_back(i);
        }
        
        for(int op = 0;; ++op) {
            vector<int> v2;
            for(int i : v) {
                if(rem[i] && nums[i] > nums[ne[i]]) {
                    rem[ne[i]] = 0;
                    ne[i] = ne[ne[i]];
                    v2.push_back(i);
                }
            }
            if(v2.size()) {
                v.swap(v2);
            } else {
                return op;
            }
        }
        
        // 不可达
        return -1;
    }
};
```